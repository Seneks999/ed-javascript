<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="css/jsgo.css" />

    <title>JavaScript</title>
  </head>
  <body>
    <section>
      <nav class="nav">
        <h1>JavaScript 3.0</h1>
        <ol>
          <li>
            <a href="#module-one"
              >Модуль 1. Змінні та типи. Основи функцій. Module 1: Variables and
              types. The basics of functions.</a
            >
          </li>
          <li><a href="#"></a></li>
          <li><a href="#"></a></li>
          <li><a href="#"></a></li>
          <li><a href="#"></a></li>
        </ol>
      </nav>
    </section>

    <section>
      <div class="container">
        <!-- Словник -->
        <h2>Словник.</h2>
        <p>
          <dfn>Інструкція (statements)</dfn> — це повний блок коду, який виконує
          певну дію або набір дій. Інструкція може складатися з одного або
          кількох виразів і зазвичай закінчується крапкою з комою ;. Інструкції
          часто використовуються для управління потоком виконання коду.
        </p>
        <p>
          Види інструкцій. Оголошення змінних: let x = 10; Умовні оператори: if
          (condition) {...}; Цикли: for, while; Виклик функції: myFunction();
        </p>
        <p>
          <dfn>Вираз (Expression) </dfn>— це будь-який фрагмент коду, який може
          бути обчислений та повертає значення. Вирази можуть включати числа,
          рядки, змінні, функції, та операції між ними. Вирази можуть бути
          частиною інструкції.
        </p>
        <p>
          Види виразів: числові вирази: 3 + 7, логічні вирази: x > 10, рядкові
          вирази: "Hello" + " World".
        </p>

        <p>
          <dfn>Оператор</dfn> — це спеціальний символ або ключове слово, яке
          виконує певну дію над одним або кількома значеннями або змінними.
          Оператори дозволяють виконувати арифметичні обчислення, логічні
          порівняння, присвоєння значень змінним і багато іншого.
        </p>

        <p>Приклади операторів:</p>
        <p>
          Арифметичні оператори: +, -, *, / (додавання, віднімання, множення,
          ділення).
        </p>
        <p>Логічні оператори: &&, ||, ! (логічне "і", "або", "не").</p>
        <p>
          Оператори порівняння: ==, ===, !=, > (рівність, строга рівність,
          нерівність, більше).
        </p>
        <p>Оператор присвоєння: = (присвоєння значення змінній).</p>

        <!-- Констект -->
        <h3>
          Інструкції для роботи с консолью в браузері. Instructions for working
          with the console in a browser.
        </h3>
        <p>Прописати в браузері <mark>about:blank</mark></p>
        <p>
          Прописати <mark>allow pasting</mark> (якщо треба) щоб дозволити
          вставлення коду.
        </p>
        <p>
          <mark>console.clear()</mark> - це треба прописати в консолі, щоб
          видалити з нього код.
        </p>

        <p id="lit"></p>
        <p id="global"></p>
        <p id="defined"></p>

        <h2 id="module-one">
          Модуль 1. Змінні та типи. Основи функцій. Module 1: Variables and
          types. The basics of functions.
        </h2>

        <h3>Базова термінологія JavaScript. Basic JavaScript terminology.</h3>

        <p>
          <dfn>Код</dfn> — це набір інструкцій, які комп'ютер може зрозуміти й
          виконати.
        </p>
        <p>
          <dfn>Компілятор, інтерпретатор</dfn> - спеціальна програма, яка
          конвертує вихідний код у набір інструкцій, зрозумілих комп'ютеру.
        </p>
        <p>
          <dfn>Вихідний код (source code)</dfn> — це текст комп'ютерної
          програми, набір синтаксичних конструкцій, що описують набір інструкцій
          для комп'ютера.
        </p>
        <p><dfn>Алгоритм</dfn> — це набір кроків, задля досягнення мети.</p>
        <p><dfn>Алгоритм</dfn> створення програми</p>
        <ul>
          <li>розбити завдання на більш дрібні підзавдання;</li>
          <li>визначити послідовність виконання підзавдань;</li>
          <li>
            використовувати відповідні інструменти для розв’язання завдання.
          </li>
        </ul>

        <p>
          Необхідно добре знати синтаксис мови, тренуватися мислити алгоритмічно
        </p>

        <p>
          <dfn>Інструкція (statement)</dfn> — це пов'язаний набір слів і
          символів із синтаксису мови, які об'єднуються, щоб висловити одну
          ідею.
        </p>

        <code><pre>a = b * 2;</pre></code>
        <p>
          інструкції закінчуються <mark><code>;</code></mark>
        </p>
        <p>
          <mark><code>a</code></mark> і <mark><code>b</code></mark> — змінні —
          це сховища даних, які складаються з ідентифікатора (імені) та
          пов'язаного з ним значення.
        </p>

        <mark><code>2</code></mark> — просто число - називається значенням
        літералу (literal value).

        <p>
          <mark><code>= *</code></mark
          >— оператори, що виконують дії над значеннями та змінними.
        </p>

        <h3>Вираз та літерал. Expression and literal.</h3>

        <p>
          <dfn>Вираз (expression)</dfn> — це посилання на змінну чи значення,
          або на набір змінних і значень у поєднанні з операторами.
        </p>

        <p>
          <mark><code>b * 2</code></mark> — арифметичний вираз множення.
        </p>
        <p>
          <mark><code>a = b * 2</code></mark> — вираз присвоювання.
        </p>

        <p>
          Існують інші типи виразів: вирази виклику функцій, вирази порівняння
          тощо.
        </p>
        <code>
          <pre>
// Числовий літерал
10

// Рядковий літерал
"JavaScript is awesome!"
            </pre
          >
        </code>

        <h3>Підключення скрипта. Connect the script.</h3>
        <p>
          Для підключення скрипта JavaScript до HTML-сторінки можна використати
          тег <code>&lt;script&gt;</code>. Існує кілька способів, як це можна
          зробити:
        </p>

        <!-- Твій JavaScript-код тут -->
        <h5>Вбудований код з виводом інформаціє на веб сторінку</h5>

        <p id="definedd"></p>
        <script>
          const hi = 'Hello, world';
          console.log(hi);
          document.getElementById('definedd').innerText = hi;
        </script>

        <p>
          <dfn>Суворий режим (англ. strict mode)</dfn> — режим повної
          відповідності сучасному стандарту, що запобігає певним помилкам,
          наприклад, використанню небезпечних і застарілих конструкцій.
        </p>
        <p>
          Щоб увімкнути суворий режим, потрібно додати директиву 'use strict';
          на початок скрипта.
        </p>

        <p>
          Комбінації клавіш відкривають інструменти розробника на вкладці
          Console: <mark>Ctrl + Shift + J;</mark>
        </p>

        <h4>Метод <code>console.log()</code></h4>
        <code>
          <pre>
              console.log("JavaScript is awesome!");
              console.log(10);
            </pre
          >
        </code>
        <script>
          console.log('JavaScript is awesome!');
          console.log(10);
        </script>

        <h3>Перевизначення значення. Overriding a value.</h3>
        <code>
          <pre>
              let username = "Mango";
              username = "Poly";
            </pre
          >
        </code>

        <p>
          Для оголошення змінної, якій згодом можна задати нове значення,
          використовується ключове слово <mark>let</mark>.
        </p>
        <p id="usernamePoly"></p>

        <p>
          Змінним, оголошеним через let, необов'язково відразу задавати
          значення. У разі оголошення змінної без значення, змінна
          ініціалізується зі спеціальним значенням
          <dfn>undefined (англ. не визначено)</dfn>.
        </p>

        <p id="userNameUndefined"></p>

        <p>
          Якщо звернутися до змінної до її оголошення з'явится помилка:
          "ReferenceError: age is not defined"
        </p>

        <p id="userAge"></p>

        <h3>Типи даних. Data types.</h3>

        <p>
          <dfn>Числа (Number)</dfn> - можуть бути позитивними, негативними,
          цілими або дробовими. Ціла та дробова частини числа розділяються
          крапкою.
        </p>

        <p>
          <dfn>Рядок (String)</dfn> - є послідовністю символів, вкладених в
          одинарні '' або подвійні лапки "".
        </p>

        <p>
          <dfn>Логічний тип даних (Boolean)</dfn> має лише два значення: true і
          false (пишеться без лапок на відміну від рядка).
        </p>

        <p>
          Імена змінних, що містять логічні значення, звучать як питання, на яке
          можна відповісти “так” чи “ні”.
        </p>

        <p>
          <dfn>Undefined:</dfn> Тип даних, який має одне значення — undefined.
          Це означає, що змінна була оголошена, але їй не було присвоєно
          значення.
        </p>

        <code>
          <pre>
let x;
console.log(x); // undefined</pre
          >
        </code>

        <p>
          <dfn>Null:</dfn> Це спеціальне значення, яке означає "немає значення".
          Тип null також є примітивним типом.
        </p>

        <code>
          <pre>
let y = null;
console.log(y); // null</pre
          >
        </code>

        <p>
          <dfn>Object:</dfn> Складний тип даних, який використовується для
          зберігання колекцій даних і складних сутностей. Прикладом об'єкта є
          об'єкт {} або масив []
        </p>

        <code>
          <pre>
let obj = { name: "Alice", age: 30 };
let arr = [1, 2, 3];</pre
          >
        </code>
        <p>
          <dfn>BigInt:</dfn> Цей тип даних дозволяє працювати з цілими числами,
          які виходять за межі діапазону типу Number.
        </p>
        <code>
          <pre>
let bigInt = 1234567890123456789012345678901234567890n;
console.log(bigInt); // 1234567890123456789012345678901234567890n</pre
          >
        </code>
        <p>
          <dfn>Symbol:</dfn> Це унікальний і незмінний примітивний тип даних,
          який використовується для створення унікальних ідентифікаторів для
          об'єктів.
        </p>

        <code>
          <pre>
let sym = Symbol("description");
console.log(sym); // Symbol(description)</pre
          >
        </code>

        <h3>Спеціальні значення. Special values.</h3>

        <p>
          <code><dfn>null</dfn></code> вказує на відсутність значення, часто
          використовується для позначення порожнього значення (має бути явно
          присвоєно змінній).
        </p>

        <code><dfn>undefined</dfn></code> автоматично присвоюється змінній,
        якщо:
        <ul>
          <li>змінній було явно задано значення undefined;</li>
          <li>
            змінна була оголошена, але ще не була ініціалізована значенням.
          </li>
        </ul>

        <p>
          Значення undefined каже нам, що значення на даний момент невідоме чи
          невизначене.
        </p>

        <h3>Оператор typeof. Operator typeof.</h3>

        <p>
          <code><dfn>typeof</dfn></code>
          використовується для визначення типу даних значення або виразу.
        </p>

        <p>
          <code><dfn>typeof</dfn></code> для перевірки типу значення null, він
          повертає рядок object.
        </p>

        <p>
          В ранніх версіях JavaScript null було розглянуто як спеціальний
          випадок об’єкта - це була помилка в реалізації мови, збережена для
          забезпечення зворотної сумісності з існуючим кодом.
        </p>

        <h3>Арифметичні операції</h3>

        <p>
          Правила порядку виконання операцій аналогічні математичним: спершу дії
          в дужках, потім степені й корені, потім множення та ділення тощо.
        </p>

        <ul>
          <li>
            Оператор (+) використовується для складання двох чисел.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x + y); // 13</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (-) використовується для віднімання одного числа від
            іншого.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x - y); // 3</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (*) використовується для множення двох чисел.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x * y); // 40</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (/) використовується для ділення одного числа на інше.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x / y); // 1.6</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (%) повертає остачу від ділення одного числа на інше.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x % y); // 3</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (**) використовується для піднесення числа до степеня.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x ** y); // 32768</pre
                >
              </code>
            </p>
          </li>
        </ul>

        <p>
          Доповни код, присвоївши змінній totalPrice вираз для підрахунку
          загальної суми замовлення. Змінна pricePerItem зберігає ціну за
          одиницю товару, а orderedQuantity - кількість одиниць товару в
          замовленні.
        </p>

        <p>
          <code>
            <pre>
const pricePerItem = 3500;
const orderedQuantity = 4;

// Change code below this line
const totalPrice = pricePerItem * orderedQuantity;</pre
            >
          </code>
        </p>

        <p>
          <dfn>Комбіновані оператори</dfn> дозволяють більш компактно виконувати
          арифметичні операції та одночасно оновлювати значення змінної,
          виходячи з її попереднього значення.
        </p>

        <ul>
          <li>
            <dfn>Додавання:</dfn> <code>+=</code>. Приклад:
            <code>x += y</code> еквівалентно <code>x = x + y</code>
          </li>
          <li>
            <dfn>Віднімання:</dfn> <code>-=</code>. Приклад:
            <code>x -= y</code> еквівалентно <code>x = x - y</code>
          </li>
          <li>
            <dfn>Множення:</dfn> <code>*=</code>. Приклад:
            <code>x *= y</code> еквівалентно <code>x = x * y</code>
          </li>
          <li>
            <dfn>Ділення:</dfn> <code>/=</code>. Приклад:
            <code>x /= y</code> еквівалентно <code>x = x / y</code>
          </li>
          <li>
            <dfn>Остача від ділення:</dfn> <code>%=</code>. Приклад:
            <code>x %= y</code> еквівалентно <code> x = x % y</code>
          </li>
        </ul>

        <p id="age"></p>

        <h3>
          Конкатенація (склеювання) рядків. Concatenation (gluing) of strings.
        </h3>
        <p>
          Якщо застосувати оператор + до рядка та будь-якого іншого типу даних,
          результатом буде новий рядок, що містить об'єднання вихідних значень.
          Це називається <dfn>конкатенація (склеювання)</dfn>. Під час
          конкатенації будь-який тип даних буде приведено до рядка та поєднано з
          іншим рядком.
        </p>

        <p>
          <code>
            <pre>
const message = "Mango " + "is" + " happy";
console.log(message); // "Mango is happy"</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
const age = 24;
const message = "Poly is " + age + " years old!";</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
console.log("Mango" + 55); // "Mango55"
console.log("Mango" + true); // "Mangotrue"</pre
            >
          </code>
        </p>

        <p>
          Проте порядок операндів має значення. Перетворення типів відбувається
          лише в момент операції додавання з рядком. До цього моменту
          застосовуються нормальні правила математики.
        </p>

        <p>
          <code>
            <pre>
console.log(1 + "2"); // "12"
console.log(1 + "2" + 4); // "124"
console.log(1 + 2 + "4"); // "34"</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
const username = "Poly";
const message = "Welcome " + username + "!";
console.log(message);</pre
            >
          </code>
        </p>

        <h3>Перетворення типів: рядки. Converting types: strings.</h3>
        <p>
          Перетворення типів у JavaScript — це процес зміни значення одного типу
          даних на інший тип даних. У JavaScript існують два типи перетворення:
          явне та неявне.
        </p>

        <h4>Явне перетворення типів</h4>
        <p>
          Для перетворення будь-якого значення на рядок можна використовувати
          вбудовану функцію <code>String()</code>
        </p>

        <p>
          <code>
            <pre>
console.log(String(5)); // "5"
console.log(String(true)); // "true"
console.log(String(false)); // "false"
console.log(String(null)); // "null"
console.log(String(undefined)); // "undefined"</pre
            >
          </code>
        </p>
        <p>
          Наприклад, якщо виконується операція додавання (<code>+</code>) між
          рядком та іншим типом даних, JavaScript автоматично перетворює
          значення операнда на рядок і виконує конкатенацію рядків.
        </p>

        <h4>Неявне перетворення типів</h4>

        <p>
          <code>
            <pre>
console.log("5" + 3); // "53"
console.log("5" + true); // "5true"
console.log("5" + false); // "5false"
console.log("5" + null); // "5null"
console.log("5" + undefined); // "5undefined"</pre
            >
          </code>
        </p>

        <p>
          <dfn>Шаблонні рядки</dfn> — це синтаксис, який полегшує об'єднання
          статичного тексту з динамічним (тобто текстом, що містить змінні,
          обчислення тощо).
        </p>

        <p>
          Код не працюватиме, якщо огорнути шаблонні рядки звичайними одинарними
          або подвійними лапками.
        </p>

        <p>
          Шаблонні рядки дозволяють підставляти значення змінних безпосередньо
          всередині рядка за допомогою синтаксису інтерполяції
          <code>${змінна}</code>.
        </p>

        <p>
          <code>
            <pre>
const guestName = "Mango";
const roomNumber = 207;
const greeting = `Welcome ${guestName}, your room number is ${roomNumber}!`;
console.log(greeting); // "Welcome Mango, your room number is 207!"</pre
            >
          </code>
        </p>

        <h4>Порівняння конкатенації та шаблонних рядків</h4>

        <p>Код з конкатенацією.</p>
        <p>
          <code>
            <pre>
const guestName = "Mango";
const roomNumber = 207;
const greeting =
  "Welcome " + guestName + ", your room number is " + roomNumber + "!";
console.log(greeting); // "Welcome Mango, your room number is 207!"</pre
            >
          </code>
        </p>

        <p>Код, де значення змінних підставляються у шаблонний рядок.</p>
        <p>
          <code>
            <pre>
const guestName = "Mango";
const roomNumber = 207;
const greeting = `Welcome ${guestName}, your room number is ${roomNumber}!`;
console.log(greeting); // "Welcome Mango, your room number is 207!"</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
const productName = "Droid";
const pricePerItem = 3500;

// Change code below this line
const message = `You picked ${productName}, price per item is ${pricePerItem} credits`;</pre
            >
          </code>
        </p>

        <h4>Замовлення продукту</h4>

        <p>
          <code>
            <pre>
const pricePerDroid = 800;
const orderedQuantity = 6;
const deliveryFee = 50;
const totalPrice = pricePerDroid * orderedQuantity + deliveryFee;
const message = `You ordered droids worth ${totalPrice} credits`;
console.log(message);</pre
            >
          </code>
        </p>

        <h3>Довжина рядка. Length of the string.</h3>
        <p><dfn>Властивості</dfn> — це описові характеристики сутності.</p>
        <p>
          Для доступу до властивості (<mark>property</mark>) сутності
          (<mark>objectName</mark>) використовується синтаксис із крапкою:
        </p>

        <p><code>сутність.властивість</code></p>

        <p>
          Наприклад, щоб отримати довжину рядка, ми можемо використовувати
          властивість <code>length</code> таким чином:
        </p>

        <p>
          <code>
            <pre>
const productName = "Repair droid";

// Якщо у змінній зберігається рядок
console.log(productName.length); // 12

// Якщо рядковий літерал
console.log("Repair droid".length); // 12</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
const username = "Poly";
const message = `Username ${username} is ${username.length} characters long`;
console.log(message);

Username Poly is 4 characters long
</pre
            >
          </code>
        </p>

        <h4>Індексація рядків. String indexing.</h4>
        <p>
          <dfn>Рядки</dfn> — це набори символів, де кожен символ має свій
          порядковий номер (індекс). Індексація елементів рядка починається з
          нуля.
        </p>

        <p>
          Для доступу до певного символу рядка ми використовуємо синтаксис
          квадратних дужок, де вказуємо індекс потрібного символу:
          <code>string[index]</code>.
        </p>

        <p>
          <code>
            <pre>
const product = "Repair droid";
console.log(product[0]); // 'R'
console.log(product[5]); // 'r'
console.log(product[11]); // 'd'
</pre
            >
          </code>
        </p>

        <p>
          Отримання останнього символу рядка можливе за його індексом
          <code>string[lastIndex]</code>. Щоб знайти індекс останнього символу
          рядка, треба від довжини цього рядка відняти одиницю
          <code>string.length - 1</code>
        </p>

        <p>
          <code>
            <pre>
const product = "Repair droid";
const lastElementIndex = product.length - 1;
console.log(product[lastElementIndex]); // 'd'
</pre
            >
          </code>
        </p>

        <p>
          Для доступу до останнього символу рядка без створення проміжної
          змінної ми можемо вставити вираз (<code>product.length - 1</code>) у
          квадратні дужки при зверненні до елемента.
        </p>

        <p>
          <code>
            <pre>
const product = "Repair droid";
console.log(product[product.length - 1]); // 'd'
</pre
            >
          </code>
        </p>

        <p>Додай код, який записує у змінні наступні значення:</p>

        <p><code>courseTopicLength</code> - довжина рядка</p>
        <p><code>firstElement</code> - перший символ рядка</p>
        <p>
          <code>lastElement</code> - останній символ рядка (використовуй змінну
          courseTopicLength)
        </p>

        <p>
          <code>
            <pre>
const courseTopic = "JavaScript essentials";

const courseTopicLength = courseTopic.length;
const firstElement = courseTopic[0];
const lastElement = courseTopic[courseTopicLength - 1]; 

</pre
            >
          </code>
        </p>

        <h3>Незмінність рядків. String immutability.</h3>

        <p>
          Коли рядок створюється, він стає незмінним (не можна замінити окремі
          символи всередині рядка).
        </p>

        <p>
          <code>
            <pre>
let product = "Droid";
console.log(product); // "Droid"

// Це не має жодного ефекту
product[2] = "O";
console.log(product); // "Droid" 
</pre
            >
          </code>
        </p>

        <p>
          Натомість ми повинні створити новий рядок і присвоїти його змінній
          новий рядок замість старого .
        </p>

        <p>
          <code>
            <pre>
let product = "Droid";
console.log(product); // "Droid"

product = "DrOid";
console.log(product); // "DrOid"
</pre
            >
          </code>
        </p>

        <!-- Section: Comparison operators.-->

        <h3>Оператори порівняння. Comparison operators.</h3>

        <p>
          Оператори порівняння повертають булеве значення (<code>true</code> або
          <code>false</code>) залежно від результату порівняння.
        </p>

        <p>Оператор &gt; (більше);</p>
        <p>Оператор &lt; (менше);</p>
        <p>Оператор &gt;= (більше або дорівнює);</p>
        <p>Оператор &lt;= (менше або дорівнює)</p>

        <p>
          <code>
            <pre>
const a = 2;
const b = 5;

console.log(a &gt; b); // false
console.log(b &gt; a); // true
console.log(a &gt;= b); // false
console.log(b &gt;= a); // true

console.log(a &lt; b); // true
console.log(b &lt; a); // false
console.log(a &lt;= b); // true
console.log(b &lt;= a); // false
</pre
            >
          </code>
        </p>

        <p>
          Оголоси змінну <code>isAdult</code> та задай їй результат перевірки
          значення змінної <code>age</code>. Використай оператори порівняння та
          доповни код так, щоб значенням <code>isAdult</code> було
          <code>true</code>, якщо вік користувача більше або дорівнює 18 та
          <code>false</code>, якщо менше 18.
        </p>

        <p>
          <code>
            <pre>
const age = 16; 
const isAdult = age >= 18;

console.log(isAdult);
</pre
            >
          </code>
        </p>

        <h3>Оператори рівності</h3>

        <p>Оператор == (дорівнює);</p>
        <p>Оператор != (не дорівнює);</p>

        <p>
          <code>
            <pre>
console.log(5 == 5); // true
console.log(5 == 3); // false
console.log(5 != 3); // true
console.log(5 != 5); // false
</pre
            >
          </code>
        </p>

        <p>Оператор === (сувора рівність);</p>
        <p>Оператор !== (сувора нерівність)</p>

        <p>
          <code>
            <pre>
console.log(5 === 5); // true
console.log(5 === "5"); // false
console.log(5 !== "5"); // true
console.log(5 !== 5); // false
console.log(1 === true); // false
console.log(1 !== true); // true
</pre
            >
          </code>
        </p>

        <p>
          Оголоси змінну <code>isValid</code> і задай їй значенням результат
          перевірки рівності паролей в змінних <code>correctPassword</code> і
          <code>userPassword</code>. Якщо паролі співпадають (сувора рівність),
          значення <code>isValid</code> має бути true Якщо паролі не
          співпадають, значення <code>isValid</code> має бути <code>false</code>
        </p>

        <p>
          <code>
            <pre>
const correctPassword = "jqueryismyjam";
const userPassword = "mangodab3st";
const isValid = correctPassword === userPassword;
</pre
            >
          </code>
        </p>

        <h4>Перетворення типів: числа</h4>
        <p>
          Для явного перетворення будь-якого значення в число можна
          використовувати вбудовану функцію <code>Number()</code>, яка повертає
          результат у вигляді числа.
        </p>

        <p>
          <code>
            <pre>
console.log(Number("5")); // 5
console.log(Number(true)); // 1
console.log(Number(false)); // 0
console.log(Number(null)); // 0
</pre
            >
          </code>
        </p>

        <p>true завжди приводиться до 1;</p>
        <p>false , null і "" завжди приводяться до 0.</p>

        <p>
          Якщо неможливо привести значення до числа, результатом перетворення
          буде спеціальне значення <code>NaN</code> (Not a Number).
        </p>

        <p>
          <code>
            <pre>
console.log(Number(undefined)); // NaN
console.log(Number("Jacob")); // NaN
console.log(Number("25px")); // NaN
</pre
            >
          </code>
        </p>

        <p>
          Арифметичні операції (<code>+, -, *, /</code>) виконують неявне
          перетворення типів.
        </p>

        <p>
          <code>
            <pre>
console.log("5" * 2); // 10
console.log("10" - 5); // 5
console.log(5 + true); // 6
console.log(5 - true); // 4
</pre
            >
          </code>
        </p>

        <p>
          Якщо у виразі присутній хоча б один із операндів з типом числа, то
          обидва операнди приводяться до чисел. Це відбувається у всіх
          арифметичних операціях, окрім додавання. + біля рядкових операндів
          викликає їх з'єднання (конкатинацію).
        </p>

        <p>
          У разі використання операторів порівняння (&lt;, &gt;, &lt;=, &gt;=)
          також виконується неявне перетворення типів. Якщо операнди різних
          типів, то перед порівнянням вони приводяться до числа.
        </p>

        <p>
          <code>
            <pre>
console.log("10" &gt; 5); // true
console.log(10 &gt; "5"); // true
console.log(5 &gt; true); // true
console.log(5 &lt; true); // false
console.log("5" &lt; true); // false
</pre
            >
          </code>
        </p>

        <h3>Перетворення рядків у числа.</h3>

        <p>Метод <code>Number.parseInt()</code> приймає 2 аргументи:</p>

        <ul>
          <li>
            Рядок. Якщо аргумент не є рядком, то він буде спочатку перетворений
            у рядок
          </li>
          <li>
            Система числення, до якої відноситься рядок (не обов’язковий
            аргумент, за замовчуванням десяткова система). Наприклад, для
            десяткової системи буде 10, для шістнадцяткової - 16 тощо.
          </li>
        </ul>

        <p>
          Метод аналізує рядок зліва направо, видаляючи пробіли на початку і
          перетворюючи допустимі символи у число до тих пір, поки не зіткнеться
          з першим недопустимим символом. Після цього аналіз припиняється, і вже
          перетворене ціле число повертається.
        </p>

        <p>
          <code>
            <pre>
console.log(Number.parseInt("5")); // 5
console.log(Number.parseInt("5.5")); // 5
console.log(Number.parseInt("5cm")); // 5
console.log(Number.parseInt("12qwe74")); // 12
console.log(Number.parseInt("12.46qwe79")); // 12
console.log(Number.parseInt("cm5")); // NaN
console.log(Number.parseInt("")); // NaN
console.log(Number.parseInt("qweqwe")); // NaN
</pre
            >
          </code>
        </p>

        <p>
          Якщо перші символи рядка не можуть бути перетворені на число, або
          рядок порожній чи відсутній, результатом буде значення NaN (Not a
          Number).
        </p>

        <h4>Метод <code>Number.parseFloat()</code></h4>

        <p>
          Метод <code>Number.parseFloat()</code> аналогічний
          <code>Number.parseInt()</code> з однієї відмінністю: перетворює рядок
          на число з плаваючою крапкою.
        </p>

        <p>
          <code>
            <pre>
console.log(Number.parseFloat("5")); // 5
console.log(Number.parseFloat("5.5")); // 5.5
console.log(Number.parseFloat("3.14")); // 3.14
console.log(Number.parseFloat("5cm")); // 5
console.log(Number.parseFloat("5.5cm")); // 5.5
console.log(Number.parseFloat("12qwe74")); // 12
console.log(Number.parseFloat("12.46qwe79")); // 12.46
console.log(Number.parseFloat("cm5")); // NaN
console.log(Number.parseFloat("")); // NaN
console.log(Number.parseFloat("qweqwe")); // NaN
</pre
            >
          </code>
        </p>

        Порожній чи відсутній, результатом буде значення
        <code>NaN (Not a Number)</code>.

        <!--  -->
        <h4>Арифметичні функції. Arithmetic functions.</h4>

        <p>
          Клас Math надає методи для виконання математичних операцій та роботи з
          числами.
        </p>
        <p>Клас Math є вбудованим класом JavaScript.</p>
        <p>Кілька методів, які надає клас Math:</p>

        <ul>
          <li>
            <mark>Math.floor(num):</mark> повертає найближче ціле число, яке є
            меншим або дорівнює вказаному числу <mark>num</mark>.

            <code>
              <pre>
    console.log(Math.floor(1.3)); // 1
    console.log(Math.floor(1.7)); // 1
            </pre
              >
            </code>
          </li>

          <li>
            <mark>Math.ceil(num):</mark> повертає найближче ціле число, яке є
            більшим, або дорівнює зазначеному числу <mark>num</mark>.
            <p>
              <code>
                <pre>
    console.log(Math.ceil(1.3)); // 2
    console.log(Math.ceil(1.7)); // 2
                  </pre
                >
              </code>
            </p>
          </li>

          <li>
            <mark>Math.round(num):</mark> повертає значення числа після
            округлення за математичними правилами - якщо десяткова частина числа
            менша 0.5, то округлення буде в меншу сторону, якщо 0.5 і більше —
            то в більшу.<mark>num</mark>.
            <p>
              <code>
                <pre>
    console.log(Math.round(1.3)); // 1
    console.log(Math.round(1.7)); // 2
                  </pre
                >
              </code>
            </p>
          </li>

          <li>
            <mark>Math.max(num1, num2, ...):</mark> повертає найбільше число з
            набору переданих чисел.
            <p>
              <code>
                <pre>
    console.log(Math.max(20, 10, 50, 40)); // 50
                </pre>
              </code>
            </p>
          </li>

          <li>
            <mark>Math.min(num1, num2, ...):</mark> повертає найменше число з
            набору переданих чисел.
            <p>
              <code>
                <pre>
    console.log(Math.min(20, 10, 50, 40)); // 10
                </pre>
              </code>
            </p>
          </li>

          <li>
            <mark>Math.random():</mark> повертає випадкове число в діапазоні від
            0 (включно) до 1 (за винятком).
            <p>
              <code>
                <pre>
    console.log(Math.random()); // випадкове число між 0 і 1, наприклад 0.2 ... 0.9166353649342294
                </pre>
              </code>
            </p>
          </li>

          <p>
            Math, також надає методи для тригонометричних функцій, логарифмів та
            інших математичних операцій.
          </p>
        </ul>

        <h4>Дробове число. Fractional number.</h4>
        <p>0.1 + 0.2 не дорівнює 0.3.</p>
        <p>
          Число 0.1 у двійковій системі числення, яку використовує комп'ютер —
          це нескінченний дріб.
        </p>
        <p>
          Двійкове значення нескінченних дробів зберігається лише до певного
          знака.
        </p>
        <p>
          <code>
            <pre>
    console.log(0.1 + 0.2 === 0.3); // false
    console.log(0.1 + 0.2); // 0.30000000000000004
                  </pre
            >
          </code>
        </p>
        <p>
          Щоб при додаванні двох дробових чисел, наприклад 0.1 + 0.2 виходило
          0.3, можна використати два підходи.
        </p>
        <ul>
          <li>
            1. Помножити числа на досить велике число (наприклад, 10 або 100),
            виконати додавання, зозділити результат на те саме число, щоб
            повернути його до початкового масштабу.
            <code>
              <pre>
    console.log(0.1 * 10 + 0.2 * 10); // 3
    console.log((0.1 * 10 + 0.2 * 10) / 10); // 0.3
                  </pre
              >
            </code>
          </li>
          <li>
            2. Метод <code><mark>toFixed()</mark></code> для округлення
            результату до певної кількості знаків після крапки.
            <code>
              <pre>
    console.log((0.1 + 0.2).toFixed(1)); // "0.3"
    console.log((5).toFixed(2));  //  ”5.00”
    console.log((8.762195).toFixed(4));  //  “8.7622”
                  </pre
              >
            </code>
          </li>
        </ul>

        <!--  -->
        <h3>Основи функцій. The basics of functions.</h3>
        <h4>Оголошення та виклик функції. Declaring and calling functions.</h4>
        <p>Cтруктура оголошення функції</p>
        <ol>
          <li>Ключове слово function</li>
          <li>
            Ім'я функції — дієслово, що відповідає на питання "Що зробити?"
          </li>
          <li>Пара круглих дужок ()</li>
          <li>Тіло функції у фігурних дужках {}</li>

          <code>
            <pre>
    function doStuff() {
  // Тіло функції
  console.log('Log inside multiply function');
}
                  </pre
            >
          </code>
        </ol>
        <p>
          Тіло функції містить інструкції, які потрібно виконати. Ці інструкції
          можуть включати оператори, умовні конструкції, цикли та інші функції.
        </p>
        <p>
          Коли функцію потрібно виконати, вона викликається за допомогою її
          імені та пари круглих дужок.
        </p>
        <code>
          <pre>
    // Оголошення функції multiply
function doStuff() {
  // Тіло функції
  console.log('Log inside multiply function');
}

// Виклики функції multiply
doStuff(); // 'Log inside multiply function'
doStuff(); // 'Log inside multiply function'
doStuff(); // 'Log inside multiply function'
                  </pre
          >
        </code>
        <h4>Параметри та аргументи. Parameters and arguments.</h4>
        <dfn>Параметри</dfn> — це локальні змінні, доступні лише всередині тіла
        функції.
        <p>
          Функція може мати будь-яку кількість параметрів або не мати їх
          взагалі, у такому випадку вказуються порожні круглі дужки.
        </p>

        <code>
          <pre>
        // Оголошення параметрів x, y, z
function multiply(x, y, z) {
  console.log(`Result: ${x * y * z}`);
}
        </pre
          >
        </code>

        <p>
          Під час виклику функції в круглих дужках можна передати аргументи, які
          є значеннями для оголошених параметрів функції.
        </p>

        <code>
          <pre>
    // Оголошення параметрів x, y, z
function multiply(x, y, z) {
  console.log(`Result: ${x * y * z}`);
}

// Передача аргументів
multiply(2, 3, 5); // "Result: 30"
multiply(4, 8, 12); // "Result: 384"
multiply(17, 6, 25); // "Result: 2550"
                  </pre
          >
        </code>
        <h4>Повернення значення. Return value.</h4>
        <p>
          Оператор return використовується для повернення значення з тіла
          функції назад у код, у місце її виклику. Коли інтерпретатор зустрічає
          оператор return, він виходить із функції (припиняє її виконання) і
          повертає вказане після return значення в місце виклику функції.
        </p>

        <code>
          <pre>
    function multiply(x, y, z) {
	const product = x * y * z;
  // Повертаємо результат виразу множення
  return product;
}

// Результат роботи функції можна зберегти у змінну
const result = multiply(2, 3, 5);
console.log(result); // 30
                  </pre
          >
        </code>
        <p>
          Щоб уникнути оголошення зайвої змінної в тілі функції, можна відразу ж
          повертати результат виразу без створення окремої змінної для
          зберігання результату виразу.
        </p>

        <code>
          <pre>
    function multiply(x, y, z) {
  return x * y * z;
}

const result = multiply(2, 3, 5);
console.log(result); // 30
                  </pre
          >
        </code>
        <p>
          Якщо в тілі функції відсутній оператор return або він не вказує на
          конкретне значення, функція поверне спеціальне значення undefined.
        </p>

        <code>
          <pre>
    function multiply(x, y, z) {
	const product = x * y * z;
}

const result = multiply(2, 3, 5);
console.log(result); // undefined
                  </pre
          >
        </code>

        <p>
          Всі інструкції які йдуть після оператора return в тілі функції не
          виконуються.
        </p>

        <code>
          <pre>
    function multiply(x, y, z) {
  console.log('The code before return is executed as usual');

  return x * y * z;

  console.log('This code is never executed because it is after return');
}

console.log(multiply(2, 3, 5)); // 30
                  </pre
          >
        </code>
        <h4>Порядок виконання коду. The order of code execution.</h4>
        <p>
          Коли інтерпретатор зустрічає виклик функції, він зупиняє виконання
          поточного коду й починає виконувати код з тіла функції.
        </p>
        <p>
          Після того, як весь код у функції буде виконано, інтерпретатор
          повертає управління в те місце, звідки був здійснений виклик функції,
          і продовжує виконання коду програми, що залишився.
        </p>
        <code>
          <pre>
     function multiply(x, y, z) {
   console.log(`Result: ${x * y * z}`);
  }

  console.log("Log before multiply execution");
  multiply(2, 3, 5); // "Result: 30"
  console.log("Log after multiply execution");
                  </pre
          >
        </code>

        <h4>Область видимості функції. The scope of the function.</h4>
        <p>
          Оголошєна змінна або функцію "видима" в певній частині коду, що
          обумовлюе можливість її використання.
        </p>

        <p>
          Змінні або функції, оголошені поза блоками коду (в глобальній області
          видимості), будуть доступні в будь-якій частині коду - це є глобальні
          змінними.
        </p>
        <p>
          Конструкція, що використовує фігурні дужки {} (умови, цикли, функції
          тощо) створює нову локальну область видимості. Змінні, оголошені в
          локальній області видимості, використовуються тільки всередині цього
          блоку коду.
        </p>
      </div>
    </section>

    <!-- Section two -->
    <section>
      <div class="container">
        <h2>Модуль 2. Розгалуження і цикли</h2>
        <h3>Розгалуження. Branching.</h3>
        <h4>Інструкція if.</h4>
        <p>
          Інструкція <mark><code>if</code></mark> дозволяє виконати певний блок
          коду тільки в тому випадку, якщо задана умова істинна (тобто приймає
          значення <mark><code>true</code></mark
          >).
        </p>

        <code>
          <pre>
     if (condition) {
  // код, який виконується, якщо умова (condition) істинна
}
                  </pre
          >
        </code>
        <p>
          К оли інтерпретатор зустрічає інструкцію <mark><code>if</code></mark
          >, він обчислює вказану умову в круглих дужках (condition),
          перетворюючи її до логічного типу (boolean). Якщо умова (condition)
          перетворюється до true, виконується блок коду, написаний у фігурних
          дужках <mark><code>{}</code></mark> — (statement).
        </p>

        <p>
          Якщо умова (condition) перетворюється до
          <mark><code>false</code></mark
          >, блок коду не виконається і продовжиться виконання програми, що іде
          після інструкції <mark><code>if.</code></mark>
        </p>
        <p>
          Якщо subscription — це "pro", тобто, умова перетворюється до true,
          price встановлюється 100.
        </p>

        <code>
          <pre>
let price = 0;
const subscription = "pro";

if (subscription === "pro") {
  price = 100;
}

console.log(price); // 100
                  </pre
          >
        </code>

        <code>
          <pre>
let price = 0;
const subscription = "free";

if (subscription === "pro") {
  price = 100;
}

console.log(price); // 0
                  </pre
          >
        </code>

        <p>
          Якщо умова перетворюється до <code>false</code>, код у фігурних дужках
          не буде виконуватися і <code>price</code> залишиться рівним 0.
        </p>

        <code>
          <pre>
function checkAge(age) {
  if (age >= 18) {
    return "You are an adult";
  }
}

// Перевірка функції
console.log(checkAge(20)); // "You are an adult"
console.log(checkAge(17)); // undefined
console.log(checkAge(10)); // undefined
console.log(checkAge(30)); // "You are an adult"
                  </pre
          >
        </code>

        <h4>Метод innerHTML</h4>
        <div id="output1"></div>
        <div id="output2"></div>
        <div id="output3"></div>
        <div id="output4"></div>

        <h4>Завдання</h4>
        <p>
          Доповнити код функції <code>checkAge(age)</code> так, щоб функція
          повертала рядок <code>"You are an adult"</code>, якщо значення
          параметра age більше або дорівнює <code>18</code>. Використай у тілі
          функції інструкцію <code>if</code> для перевірки значення age.
        </p>

        <code>
          <pre>
function checkAge(age) {
  if (age >= 18) {
    return "You are an adult";
  }
}

console.log(checkAge(20));
console.log(checkAge(17));
console.log(checkAge(10));
console.log(checkAge(30));

                  </pre
          >
        </code>

        <h4>Інструкція if...else</h4>
        <p>
          Синтаксис інструкції <code>if</code> можна доповнити блоком
          <code>else</code> для визначення альтернативних варіантів виконання
          коду.
        </p>

        <code>
          <pre>
if (condition) {
  // код, який виконується, якщо умова істинна
} else {
	// код, який виконується, якщо умова хибна
}
                  </pre
          >
        </code>

        <h4>Завдання 3</h4>
        <p>
          Якщо умова <code>(condition)</code> перетворюється до
          <code>true</code>, то виконається код блоку <code>if</code>
          <code>(if block statements)</code>.
        </p>
        <p>
          Якщо умова <code>(condition)</code> перетворюється до
          <code>false</code>, то виконається код блоку
          <code>else (else block statements)</code>.
        </p>

        <p>
          Функція checkStorage(available, ordered) перевіряє можливість
          оформлення замовлення і повертає повідомлення про результат. Вона
          оголошує два параметри, значення яких будуть задаватися під час її
          виклику:
        </p>

        <p>available - доступна кількість товарів на складі</p>
        <p>ordered - кількість одиниць товару в замовленні</p>
        <p>
          Використовуючи розгалуження, доповни код функції таким чином, щоб:
        </p>

        <p>
          Якщо в замовленні вказане число, яке перевищує доступну кількість
          товарів на складі, функція повертає рядок "Not enough goods in stock!"
        </p>
        <p>
          В іншому випадку функція повертає рядок "Order is processed, our
          manager will contact you"
        </p>

        <code>
          <pre>
function checkStorage(available, ordered) {
  if (ordered > available) {
    return "Not enough goods in stock!";
  } else {
    return "Order is processed, our manager will contact you";
  }
}

console.log(checkStorage(100, 50));
console.log(checkStorage(100, 130));
console.log(checkStorage(200, 20));
console.log(checkStorage(200, 150));
console.log(checkStorage(150, 180));</pre
          >
        </code>

        <h4>Блок else...if</h4>
        <p>
          Конструкція <code>else...if</code> розширює конструкцію
          <code>if...else</code> і дозволяє перевірити та зреагувати на
          виконання або невиконання кількох умов.
        </p>

        <code>
          <pre>
if (condition_1) {
  // код, який виконується, якщо умова (condition_1) істинна
} else if (condition_2) {
  // код, який виконується, якщо умова (condition_2) істинна
} else if (condition_3) {
  // код, який виконується, якщо умова (condition_3) істинна
} else {
	// код, який виконується, якщо всі умови хибні
}
</pre
          >
        </code>
        <p>Кожна умова послідовно перевіряється зверху вниз.</p>
        <p>
          Якщо умова <code>condition_1</code> істинна, виконується відповідний
          блок коду (тільки тіло відповідного блоку <code>if</code> або
          <code>else if</code>), і перевірка завершується.
        </p>
        <p>
          Якщо умова <code>condition_1</code> хибна, то перевіряється умова_2 і
          далі.
        </p>
        <p>
          Код у блоці else буде виконаний тільки у випадку, якщо жодна з умов у
          блоках <code>if</code> та <code>else if</code> не є істинною.
        </p>

        <p>
          У цьому прикладі спочатку перевіряється умова
          <code>grade >= 90</code>.
        </p>

        <!-- else if -->
        <code>
          <pre>
const grade = 85;

if (grade >= 90) {
  console.log("Perfectly");
} else if (grade >= 80) {
  console.log("Good");
} else if (grade >= 70) {
  console.log("Satisfactorily");
} else {
  console.log("Unsatisfactorily");
}
</pre
          >
        </code>

        <!-- Завдання 3 -->

        <p>
          Функція <code>checkStorage(available, ordered)</code> перевіряє
          можливість оформлення замовлення і повертає повідомлення про
          результат. Вона оголошує два параметри, значення яких будуть
          задаватися під час її виклику.
        </p>

        <p><code>available</code> - доступна кількість товарів на складі</p>
        <p><code>ordered</code> - кількість одиниць товару в замовленні</p>
        <p>
          Використовуючи розгалуження, доповни код функції таким чином, щоб:
        </p>

        <p>
          Якщо в замовленні ще немає товарів, тобто значення параметра
          <code>ordered</code> дорівнює <code>0</code>, функція повертає рядок
          <code>"There are no products in the order!"</code>.
        </p>
        <p>
          Якщо товарів у замовленні більше, ніж їх доступно на складі, то
          функція повертає рядок
          <code
            >"Your order is too large, there are not enough items in
            stock!"</code
          >.
        </p>
        <p>
          В іншому випадку функція повертає рядок
          <code>"The order is accepted, our manager will contact you"</code>.
        </p>

        <code>
          <pre>
function checkStorage(available, ordered) {
  if (ordered === 0) {
    return "There are no products in the order!";
  } else if (ordered > available) {
    return "Your order is too large, there are not enough items in stock!";
  } else {
    return "The order is accepted, our manager will contact you";
  }
}

// Перевірка функції
console.log(checkStorage(100, 50)); // "The order is accepted, our manager will contact you"
console.log(checkStorage(100, 130)); // "Your order is too large, there are not enough items in stock!"
console.log(checkStorage(70, 0)); // "There are no products in the order!"
console.log(checkStorage(200, 20)); // "The order is accepted, our manager will contact you"
console.log(checkStorage(200, 250)); // "Your order is too large, there are not enough items in stock!"
console.log(checkStorage(150, 0)); // "There are no products in the order!"
console.log(checkStorage(80, 80)); // "The order is accepted, our manager will contact you"
</pre
          >
        </code>

        <h3>Тернарний оператор. Ternary operator.</h3>
        <p>
          <dfn>Тернарний оператор</dfn> — це коротша синтаксична заміна
          інструкції if...else.
        </p>

        <code>
          <pre>
&lt;condition&gt; ? &lt;expression if condition is true&gt; : &lt;expression if condition is false&gt;
          </pre>
        </code>
        <p>Код з використанням інструкції if...else</p>
        <code>
          <pre>
let type;
const age = 20;

if (age >= 18) {
  type = 'adult';
} else {
  type = 'child';
}

console.log(type); // 'adult'

          </pre>
        </code>

        <p>Той самий код з використанням тернарного оператора:</p>
        <code>
          <pre>
const age = 20;
const type = age >= 18 ? 'adult' : 'child';
console.log(type); // 'adult'
          </pre>
        </code>

        <p>
          Знаходження більшого числа із двох з використанням інструкції
          <code>if...else</code>:
        </p>
        <code>
          <pre>
const a = 5;
const b = 10;
let biggerNumber;

if (a > b) {
  biggerNumber = a;
} else {
  biggerNumber = b;
}

console.log(biggerNumber); // 10
          </pre>
        </code>
        <p>Той самий код з використанням тернарного оператора:</p>
        <code>
          <pre>
const a = 5;
const b = 10;
const biggerNumber = a > b ? a : b;

console.log(biggerNumber); // 10
          </pre>
        </code>
        <p>
          Тернарний оператор рекомендується використовувати у найпростіших
          випадках операції присвоєння чи повернення. Однак не рекомендується
          використовувати його для складних розгалужень, оскільки це може
          ускладнити читання та розуміння коду.
        </p>
        <p>
          Функція checkPassword(password) порівнює переданий їй пароль (параметр
          password) зі збереженим паролем адміністратора (correctPassword) і
          повертає рядок з повідомленням про результат.
        </p>
        <p>
          Використовуючи тернарний оператор, доповни функцію таким чином, щоб:
        </p>
        <p>
          Якщо значення password і correctPassword збігаються, функція повертала
          рядок "Access granted"
        </p>
        <p>
          В іншому випадку, функція повертала рядок "Access denied, wrong
          password!"
        </p>

        <code>
          <pre>
function checkPassword(password) {
  const correctPassword = "jqueryismyjam";
  
  return password === correctPassword 
    ? "Access granted" 
    : "Access denied, wrong password!";
}

console.log(checkPassword("jqueryismyjam"));
console.log(checkPassword("angul4r1sl1f3"));
console.log(checkPassword("r3actsux"));
          </pre>
        </code>

        <h3>Оператор switch</h3>
        <p>
          Використання switch є більш компактним і зручним способом для
          порівняння виразів з кількома варіантами, ніж інструкції if...else та
          else...if.
        </p>
        <h4>Приклад використання оператора <code>switch:</code></h4>

        <code>
          <pre>
const fruit = 'apple';

switch (fruit) {
  case 'apple':
    console.log('Apple selected');
    break;
  case 'banana':
    console.log('Banana selected');
    break;
  case 'orange':
    console.log('Orange selected');
    break;
  default:
    console.log('The fruit is unknown');
}
          </pre>
        </code>
        <h4>Оператор break</h4>
        <p>
          Якщо break не вказано, виконання коду продовжиться в наступному
          <mark>case</mark> і далі. Така поведінка називається "провалюванням"
          (<mark>fall-through</mark>). Якщо потрібно, щоб кілька блоків case
          виконували той самий код, можна опустити оператор break між ними.
        </p>

        <code>
          <pre>
const day = 3;

switch (day) {
  case 1:
  case 2:
  case 3:
  case 4:
  case 5:
    console.log('This is a working day');
    break;
  case 6:
  case 7:
    console.log('It is a day off');
    break;
  default:
    console.log('Invalid');
}
          </pre>
        </code>

        <p>
          Функція getSubscriptionPrice(type) отримує рядок з типом передплати
          користувача (параметр type), перевіряє її на збіг з трьома можливими
          типами щомісячної передплати та повертає ціну, або повідомлення про
          неправильний тип передплати.
        </p>

        <p>Якщо значення параметра type — це рядок:</p>

        <p>"starter" — ціна передплати 0 кредитів.</p>
        <p>"professional" — ціна передплати 20 кредитів.</p>
        <p>"organization" — ціна передплати 50 кредитів.</p>
        <p>
          Для будь-якого іншого значення параметра type повертається рядок
          "Invalid subscription type!".
        </p>

        <p>Використання оператора switch для розв'язання цієї задачі!</p>
        <code>
          <pre>
function getSubscriptionPrice(type) {
  switch (type) {
    case "starter":
      return 0;
    case "professional":
      return 20;
    case "organization":
      return 50;
    default:
      return "Invalid subscription type!";
  }
}

console.log(getSubscriptionPrice("professional"));
console.log(getSubscriptionPrice("organization"));
console.log(getSubscriptionPrice("starter"));
console.log(getSubscriptionPrice("random"));
console.log(getSubscriptionPrice("premium"));
          </pre>
        </code>
        <h4>
          Пам’ятка під час використання розгалужень. A reminder when using
          branches.
        </h4>
        <p>
          Інструкція if є універсальною. Інструкції if…else і else…if
          використовуються, коли потрібно прописати декілька умов. Отже, ці
          інструкції зазвичай довші, ніж інші способи розгалужень.
        </p>
        <p>
          Тернарний оператор краще використовувати для присвоєння або повернення
          значення з тіла функції. В умові тернарного оператора може бути все що
          завгодно: перевірка рівності / нерівності, на більше / менше, просто
          перевірка на будь чого. Пам’ятай про обмеження: у нього має бути рівно
          2 сценарії, не більше.
        </p>
        <p>
          Оператор switch перевіряє тільки на сувору рівність. Використовуючи
          оператор switch, завжди: пам’ятай про оператор break; використовуй
          тільки 1 default, він завжди має бути останнім.
        </p>
        <h4>Блокова область видимості. Blocked viewport.</h4>
        <p>
          Під час оголошення змінної або функції, вона стає "видимою" тільки в
          певній частині коду.
        </p>
        <p>
          Змінні або функції, які оголошені поза будь-якими блоками коду — тобто
          в глобальній області видимості є глобальними змінними і будуть
          доступні в будь-якій частині коду.
        </p>
        <code>
          <pre>
// Глобальна змінна
const value = "I'm a global variable";

if (true) {
	// Можна звернутися до глобальної змінної
  console.log(value); // "I'm a global variable"
}

// Можна звернутися до глобальної змінної
console.log(value); // "I'm a global variable"
          </pre>
        </code>
        <p>
          Змінна value оголошена в глобальній області видимості (поза блоком
          коду), вона буде доступна в будь-якому місці після оголошення.
        </p>
        <p>
          Будь-яка конструкція, що використовує фігурні дужки {} (умови,
          функції, цикли тощо) створює нову локальну блочну область видимості.
          Змінні, оголошені в цій області видимості, можуть бути використані
          тільки всередині цього блоку коду. Це локальні змінні.
        </p>
        <code>
          <pre>
if (true) {
  // Локальна змінна
	const value = "I'm a local variable";
  console.log(value); // "I'm a local variable"
}

// Помилка: локальну змінну не видно за межами блоку
console.log(value); // ReferenceError: value is not defined
          </pre>
        </code>
        <p>
          Область видимості не має доступу до змінних, що оголошені у вкладених
          областях видимості.
        </p>
        <p>
          Код у блоці A має доступ до змінних, оголошених у Global, але не має
          доступу до змінних, оголошених у блоках B і C.
        </p>
        <p>
          Код у блоці B має доступ до змінних, оголошених у Global і в блоці A,
          але не має доступу до змінних, оголошених у блоці C.
        </p>
        <p>
          Код у блоці C має доступ до змінних, оголошених у Global, але не має
          доступу до змінних, оголошених у блоках A і B.
        </p>
        <code>
          <pre>
const globalVar = "Global";

console.log(globalVar); // Доступ до globalVar з глобальної області видимості
// Немає доступу до aVar, bVar і cVar

if(true) {
	const aVar = "A";
	console.log(globalVar); // Доступ до globalVariable з блоку A
  console.log(aVar); // Доступ до aVar з блоку A
	// Немає доступу до bVar і cVar

	if(true) {
		const bVar = "B";
		console.log(globalVar); // Доступ до globalVariable з блоку B
	  console.log(aVar); // Доступ до aVar з блоку B
	  console.log(bVar); // Доступ до bVar з блоку B
		// Немає доступу до cVar
	}
}

console.log(globalVar); // Доступ до globalVar із глобальної області видимості
// Немає доступу до aVar, bVar і cVar

if(true) {
	const cVar = "C";
  console.log(globalVariable); // Доступ до globalVar з блоку C
  console.log(cVar); // Доступ до cVar з блоку C
	// Немає доступу до aVar і bVar
}

console.log(globalVar); // Доступ до globalVar із глобальної області видимості
// Немає доступу до aVar, bVar і cVar
          </pre>
        </code>
        <h2>Логічні оператори. Logical operators.</h2>
        <p>
          <dfn>Логічне перетворення типів</dfn> означає приведення значення
          будь-якого типу даних у логічне (булеве) значення
          <code>true</code> або <code>false</code>. Існує кілька правил, які
          визначають, які значення перетворюються на <code>true</code>, а які на
          <code>false</code>.
        </p>
        <p>
          Ці правила працюють як для явного перетворення типів за допомогою
          функції <code>Boolean()</code>, так і для неявного в умовних
          операціях, наприклад, у конструкціях <code>if</code> чи логічних
          операторах.
        </p>
        <p>
          Логічні значення <code>true</code> та <code>false</code> залишаються
          незмінними.
        </p>
        <code>
          <pre>
console.log(Boolean(true)); // true
console.log(Boolean(false)); // false
          </pre>
        </code>
        <p>
          Число <code>0</code>, значення <code>NaN</code>, <code>null</code> і
          undefined завжди перетворюються на <code>false</code>. Усі інші числа
          перетворюються на <code>true</code>.
        </p>
        <code>
          <pre>
console.log(Boolean(NaN)); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean(0)); // false
console.log(Boolean(3.14)); // true
console.log(Boolean(-10)); // true
          </pre>
        </code>
        <p>
          У прикладі нижче начення в умові інструкцій if приводиться до false,
          отже, виконується код із блоку else.
        </p>
        <code>
          <pre>
if(null) {
	console.log("Block if")
} else {
	console.log("Block else")
}

if(0) {
	console.log("Block if")
} else {
	console.log("Block else")
}
          </pre>
        </code>
        <p>
          Значення в умові інструкції if приводиться до true, отже, виконується
          код із блоку if.
        </p>
        <code>
          <pre>
if(5) {
	console.log("Block if")
} else {
	console.log("Block else")
}
          </pre>
        </code>
        <h4>6 випадків, які приводяться до false:</h4>
        <p>1. 0</p>
        <p>2. ""</p>
        <p>3. Nan</p>
        <p>4. null</p>
        <p>5. underfined</p>
        <p>6. false</p>

        <p>
          <dfn>Оператор "І" (&&)</dfn> наводить усі операнди до логічного типу
          (<code>true</code> або <code>false</code>) і повертає значення одного
          з них. Дозволяє перевірити, чи виконані всі умови у виразі.
        </p>
        <p>
          <dfn>Оператор “І”</dfn> зліва направо перевіряє почергово обидва
          операнди на істинність та повертає або значення останнього істинного
          (тільки правого) операнда, або першого хибного (лівого чи правого), на
          якому він запнувся.
        </p>
        <code>
          <pre>
console.log("hello" && 5); // 5
console.log(5 && "hello"); // "hello"

console.log("mango" && "poly"); // "poly"
console.log("poly" && "mango"); // "mango"

console.log(3 && true); // true
console.log(true && 3); // 3
          </pre>
        </code>
        <p>
          у цьому прикладі один із операндів буде приведений до false, отже,
          результатом буде хибний операнд.
        </p>
        <code>
          <pre>
console.log("hello" && 0); // 0
console.log(0 && "hello"); // 0

console.log(3 && false); // false
console.log(false && 3); // false

console.log(0 && ""); // 0
console.log("" && 0); // ""
          </pre>
        </code>
        <p>
          У прикладі <code>“hello” && 0</code> лівий операнд приводиться до
          true, а правий до <code>false</code>, тому результатом виразу буде
          значення правого операнда, який першим був приведений до false, тобто
          <code>0</code>.
        </p>
        <p>
          У приклад <code>0 && “hello”</code> лівий операнд приводиться до
          <code>false</code>, тому правий операнд не буде обчислюватися.
          Результатом виразу буде значення лівого операнда, який першим був
          приведений до <code>false</code>, тобто <code>0</code>.
        </p>
        <p>
          якщо операндами є вирази, то спочатку вони обчислюються, а потім їх
          результати будуть порівнюватися оператором &&.
        </p>

        <h3>Логічне "АБО"</h3>
        <p>
          <dfn>Оператор "АБО" (||)</dfn> перетворює всі операнди до логічного
          типу (true або false), перевіряє чи є хочаб один із операдів "true",
          та і повертає значення одного з них. Якщо хоча б один із операндів
          можна перетворити на true, результатом логічного «АБО» буде true.
        </p>
        <code>
          <pre>
console.log("hello" && 0); // 0
cexpression1 || expression2
          </pre>
        </code>

        <code>
          <pre>
console.log(true || false); // true
console.log(false || true); // true

console.log(5 || false); // 5
console.log(false || 5); // 5

console.log("hello" || 0); // "hello"
console.log(0 || "hello"); // "hello"
          </pre>
        </code>
        <p>
          Якщо до істини було перетворено перший операнд, то другий навіть не
          буде оцінюватися. Це може мати практичне застосування, особливо коли
          другий операнд є виразом, який має високу вартість обчислення.
        </p>
        <code>
          <pre>
console.log(5 || 3); // 5
console.log(3 || 5); // 3

console.log("mango" || "poly"); // "mango"
console.log("poly" || "mango"); // "poly"
          </pre>
        </code>

        <p>
          Якщо всі операнди перетворюються на false, результатом буде значення
          крайнього правого операнда.
        </p>
        <code>
          <pre>
console.log(0 || false); // false
console.log(false || 0); // 0

console.log(null || ""); // ""
console.log("" || null); // null
          </pre>
        </code>
        <p>
          На практиці оператор «АБО» також використовується для перевірки
          множинних умов.
        </p>
        <code>
          <pre>
const a = 5;
console.log(a &lt; 10 || a &gt; 30); // true || false -&gt; true

const b = 50;
console.log(b &lt; 10 || b > 30); // false || true -&gt; true

const c = 20;
console.log(c - 20 || c * 2); // 0 || 40 -&gt; 40
          </pre>
        </code>

        <p>В умові інструкції if.</p>
        <code>
          <pre>
const screenWidth = 700;
const sm = 320;
const md = 768;
const lg = 1200;

if(screenWidth &lt;= sm || screenWidth > md) {
	console.log("Mobile or Desktop screen");
  // у консолі буде пусто, оскільки жодна з умов не перетворилась на true
}
          </pre>
        </code>
        <p>
          Функція <code>checkAccess(subType)</code> перевіряє, чи може
          користувач отримати доступ до контенту. Перевірка відбувається за
          типом передплати. Використовуючи оператор "АБО", доповни код функції
          так, щоб якщо значення параметра <code>subType</code> дорівнює рядкам
          <code>"pro"</code> або <code>"vip"</code>, то функція повертала
          <code>true</code> і користувач отримував доступ. В іншому випадку
          повертала <code>false</code>.
        </p>
        <code>
          <pre>
function checkAccess(subType) {
  return subType === "pro" || subType === "vip";
}

// Перевірка функції
console.log(checkAccess("pro")); // true
console.log(checkAccess("starter")); // false
console.log(checkAccess("vip")); // true
console.log(checkAccess("free")); // false
          </pre>
        </code>
        <p>
          <dfn>Логічне «НІ» (!)</dfn> — це унарний оператор — він виконує
          операцію над одним операндом праворуч. Логічне «НІ» приводить операнд
          до логічного значення (true або false) і потім заперечує (інвертує)
          його, тобто заміняє на протилежне: true —> false, а false —> true.
        </p>
        <code>
          <pre>
console.log(!true); // false
console.log(!false); // true
console.log(!3); // !3 -> !true -> false
console.log(!"Mango"); // !"Mango" -> !true -> false
console.log(!0); // !0 -> !false -> true
console.log(!""); // !"" -> !false -> true
console.log(!null); // !null -> !false -> true
          </pre>
        </code>
        <p>
          На практиці логічне заперечення використовується для перевірки від
          зворотного. Наприклад, можна дозволити написати повідомлення в чаті,
          лише якщо користувач не заблокований.
        </p>
        <code>
          <pre>
const isBlocked = false;
const canChat = !isBlocked; // !false -> true

if(canChat) {
	console.log("Can type in chat!")
} else {
	console.log("Blocked from typing in chat!")
}
          </pre>
        </code>

        <p>
          Функція <code>toggleModalVisibility(isVisible)</code> перемикає стан
          відображення модального вікна. У параметрі <code>isVisible</code> вона
          очікує буль <code>true</code> або <code>false</code>. Доповни код
          функції так, щоб вона повертала протилежне значення цього параметра.
        </p>
        <pre>
      <code>
function toggleModalVisibility(isVisible) {
return !isVisible;
}

console.log(toggleModalVisibility(true)); // false
console.log(toggleModalVisibility(false)); // true
      </code>
        </pre>

        <p>В JS загалом 8 видів типів даних.</p>
        <p>
          Низка функций присутня тільки в браузері. Наприклад: alert('text');
        </p>
        <h3>Прикдади використання JavaScript в html документі</h3>
        <p>Властивості — це описові характеристики сутності.</p>
        <p>Методи — це дії, які можна виконати із сутністю.</p>
        <p>Щоб отримати довжину рядка, використовується властивість length:</p>
        <pre>
      <code>
const message = "JavaScript is awesome";
console.log(message.length); // 21
      </code>
        </pre>
        <p>
          Виклик методу схожий на доступ до властивості, але наприкінці
          додаються круглі дужки, як при виклику функції:
        </p>
        <pre>
      <code>
objectName.method()
      </code>
        </pre>
        <pre>
      <code>
const message = "JavaScript is awesome";
console.log(message.toUpperCase()); // "JAVASCRIPT IS AWESOME"
      </code>
        </pre>
        <p>
          <dfn>Метод slice()</dfn> використовується для створення копії частини
          або всього рядка без зміни оригінального рядка. Він дозволяє
          витягувати підрядок з вихідного рядка, вказуючи початковий та кінцевий
          індекси.
        </p>
        <pre>
      <code>
const fullName = "Jacob Mercer";
console.log(fullName.slice(0, 4)); // 'Jaco'
console.log(fullName.slice(3, 9)); // 'ob Mer'
console.log(fullName.slice(0, fullName.length)); // 'Jacob Mercer'
      </code>
        </pre>
        <p>
          Якщо <code>endIndex</code> не вказаний, витягуються всі елементи до
          кінця рядка.
        </p>
        <pre>
      <code>
const fullName = "Jacob Mercer";
console.log(fullName.slice(1)); // 'acob Mercer'
console.log(fullName.slice(3)); // 'ob Mercer'
      </code>
        </pre>
        <p>
          Якщо викликати метод <code>slice()</code> без аргументів, він створює
          точну копію рядка і повертає її.
        </p>
        <pre>
      <code>
const fullName = "Jacob Mercer";
console.log(fullName.slice()); // 'Jacob Mercer'
      </code>
        </pre>
        <p>
          Результат виклику методу <code>slice()</code> можна зберігати в
          змінній для подальшого використання.
        </p>
        <pre>
      <code>
const fullName = "Jacob Mercer";
const firstName = fullName.slice(0, 5);
const lastName = fullName.slice(6);

console.log(fullName); // "Jacob Mercer"
console.log(firstName); // "Jacob"
console.log(lastName); // "Mercer"
      </code>
        </pre>

        Ф
        <p>
          Ф ункція getSubstring(string, length) приймає рядок і повертає новий
          підрядок (його часткову копію). Вона оголошує два параметри, значення
          яких будуть задаватися під час її виклику: Ф
        </p>
        <p>string - оригінальний рядок</p>
        <p>length - довжина нового підрядка</p>
        <p>
          Доповни код функції так, щоб вона повертала новий підрядок, який
          починається від початку string і має довжину length.
        </p>
        <pre>
      <code>
function getSubstring(string, length) {
  return string.substring(0, length);
}

console.log(getSubstring('Hello world', 3)); // "Hel"
console.log(getSubstring('Hello world', 5)); // "Hello"
console.log(getSubstring('Hello world', 8)); // "Hello wo"
console.log(getSubstring('Hello world', 11)); // "Hello world"
console.log(getSubstring('Hello world', 0)); // ""
      </code>
        </pre>
        <h3>Методи toLowerCase() і toUpperCase()</h3>
        <p>
          Метод <code>toLowerCase()</code> повертає новий рядок, у якому всі
          символи вихідного рядка перетворені в нижній регістр.
        </p>
        <pre>
      <code>
const message = "Welcome to Bahamas!";
console.log(message.toLowerCase()); // "welcome to bahamas!"
console.log(message); // "Welcome to Bahamas!"
      </code>
        </pre>
        <p>
          Метод <code>toUpperCase()</code> повертає новий рядок, у якому всі
          символи вихідного рядка перетворені у верхній регістр.
        </p>
        <pre>
      <code>
const message = "Welcome to Bahamas!";
console.log(message.toUpperCase()); // "WELCOME TO BAHAMAS!"
console.log(message); // "Welcome to Bahamas!"
      </code>
        </pre>
        <p>
          Розгляньмо ситуацію: При пошуку за ключовим словом, користувач вводить
          рядок 'saMsUng', а його треба порівняти з рядком 'samsung' або
          'SAMSUNG'.
        </p>
        <pre>
      <code>
console.log('saMsUng' === 'samsung'); // false
console.log('saMsUng' === 'SAMSUNG'); // false
      </code>
        </pre>
        <p>
          Щоб не вимагати абсолютно точного введення, можна зробити
          «нормалізацію» введеного користувачем рядка, тобто перетворити всі
          його символи у верхній або нижній регістр.
        </p>
        <pre>
      <code>
const brandName = 'samsung';
const userInput = 'saMsUng';
const lowercaseInput = userInput.toLowerCase();

console.log(brandName); // 'samsung'
console.log(userInput); // 'saMsUng'
console.log(userInput === brandName); // false
console.log(lowercaseInput); // 'samsung'
console.log(lowercaseInput === brandName); // true
      </code>
        </pre>
        <p>Функція normalizeInput(input, to) оголошує два параметри:</p>

        <p>input - рядок, який потрібно привести до певного регістру</p>
        <p>
          to - рядок с двома можливими значеннями: "upper" або "lower", що
          вказують до якого регістру потрібно привести значення input
        </p>
        Доповни код функції таким чином, щоб:

        <p>
          Якщо значення параметра to — це рядок "upper", то функція повертала
          копію рядка input, але у верхньому регістрі
        </p>
        <p>
          В іншому разі, функція повертала копію рядка inputу нижньому регістрі
        </p>
        <pre>
      <code>
function normalizeInput(input, to) {
  return to === "upper" ? input.toUpperCase() : input.toLowerCase();
}

// Приклади виклику функції та їх результати:
console.log(normalizeInput("This ISN'T SpaM", "lower")); // "this isn't spam"
console.log(normalizeInput("This ISN'T SpaM", "upper")); // "THIS ISN'T SPAM"
console.log(normalizeInput("Big SALE", "lower")); // "big sale"
console.log(normalizeInput("Big SALE", "upper")); // "BIG SALE"
console.log(normalizeInput("Stay Awhile and Listen", "lower")); // "stay awhile and listen"
console.log(normalizeInput("Stay Awhile and Listen", "upper")); // "STAY AWHILE AND LISTEN"
      </code>
        </pre>
        <ol>
          <li>
            Параметри функції:
            <ul>
              <li>input: Рядок, який потрібно перетворити.</li>
              <li>
                to: Рядок, який визначає, чи потрібно перетворити input на
                верхній або нижній регістр. Він може мати два значення: "upper"
                або "lower".
              </li>
            </ul>
          </li>
          <li>
            Умовний (тернарний) оператор:
            <ul>
              <li>
                to === "upper": Це умова, яка перевіряє, чи дорівнює значення
                параметра to рядку "upper".
              </li>
              <li>
                ?: Якщо умова істинна (тобто to === "upper"), виконується вираз
                після знака питання (input.toUpperCase()).
              </li>
              <li>
                :: Якщо умова хибна (тобто to !== "upper"), виконується вираз
                після двокрапки (input.toLowerCase()).
              </li>
            </ul>
          </li>
          <li>
            Методи toUpperCase() та toLowerCase():
            <ul>
              <li>
                input.toUpperCase(): Приводить всі символи в рядку input до
                верхнього регістру.
              </li>
              <li>
                input.toLowerCase(): Приводить всі символи в рядку input до
                нижнього регістру.
              </li>
            </ul>
          </li>
        </ol>
        <p>Як працює функція:</p>
        <ul>
          <li>
            кщо параметр to дорівнює "upper", функція повертає рядок input,
            перетворений на верхній регістр.
          </li>
          <li>
            Якщо to не дорівнює "upper" (наприклад, "lower" або будь-яке інше
            значення), функція повертає рядок input, перетворений на нижній
            регістр.
          </li>
        </ul>
        <p>Приклад:</p>
        <ul>
          <li>Виклик normalizeInput("Hello", "upper") поверне "HELLO".</li>
          <li>Виклик normalizeInput("Hello", "lower") поверне "hello".</li>
        </ul>

        <h3>Метод includes()</h3>

        <p>
          Метод рядків <code>includes()</code> використовується для перевірки
          наявності підрядка у рядку. Він повертає логічне значення
          <code>true</code>, якщо підрядок знайдено, і <code>false</code>, якщо
          підрядок відсутній.
        </p>
        <pre>
      <code>
str.includes(substring)
      </code>
        </pre>
        <p>str — вихідний рядок, у якому ми шукаємо підрядок;</p>
        <p>substring — підрядок, який ми хочемо знайти у вихідному рядку.</p>
        <pre>
      <code>
const username = 'Jacob Mercer';

console.log(username.includes('Jacob')); // true
console.log(username.includes('John')); // false
console.log(username.includes('Mercer')); // true
console.log(username.includes('Doe')); // false
      </code>
        </pre>
        <p>
          Регістр символів у рядку й підрядку має значення. Літера
          <code>a</code>, наприклад, не дорівнює літері <code>A</code>.
        </p>

        <pre>
      <code>
function checkForName(fullName, firstName) {
  // Приводимо обидва рядки до нижнього регістру
  const normalizedFullName = fullName.toLowerCase();
  const normalizedFirstName = firstName.toLowerCase();
  
  // Перевіряємо, чи входить firstName у fullName
  return normalizedFullName.includes(normalizedFirstName);
}

console.log(checkForName("Jason Neis", "Jason")); // Повертає true
console.log(checkForName("Jason Neis", "jAsOn")); // Повертає true
console.log(checkForName("Jason Neis", "Jacob")); // Повертає false
console.log(checkForName("Caty Stars", "Caty"));  // Повертає true
console.log(checkForName("Caty Stars", "cAtY"));  // Повертає true
console.log(checkForName("Caty Stars", "Andromeda")); // Повертає false
      </code>
        </pre>
        <h3>Методи startsWith() і endsWith()</h3>
        <p>
          Методи <code>startsWith()</code> і <code>endsWith()</code> призначені
          для перевірки початку й закінчення рядка відповідно. Вони повертають
          булеве значення <code>true</code> або <code>false</code>, залежно від
          того, чи відповідає початок або кінець рядка заданому значенню.
        </p>

        <pre>
      <code>
const str = "Hello, world!";

console.log(str.startsWith("Hello")); // true
console.log(str.startsWith("hello")); // false (метод чутливий до регістру)
      </code>
        </pre>

        <pre>
      <code>
const str = "Hello, world!";

console.log(str.endsWith("world!")); // true
console.log(str.endsWith("World!")); // false (метод чутливий до регістру)
      </code>
        </pre>
        <p>Функція checkFileExtension(fileName, ext) приймає два параметри:</p>

        <p>
          fileName - рядок, що зберігає ім'я файлу з розширенням, наприклад,
          styles.css, hello.js тощо.
        </p>
        <p>ext - рядок, що зберігає розширення, наприклад, .css, .js тощо</p>
        <p>Доповни код функції так, щоб:</p>

        <p>
          Якщо ім'я файлу fileName закінчується розширенням, зазначеним у
          параметрі ext, то функція повертала рядок "File extension matches"
        </p>
        <p>
          В іншому разі, функція повертала рядок "File extension does not match"
        </p>
        <pre>
      <code>
function checkFileExtension(fileName, ext) {
  if (fileName.endsWith(ext)) {
    return "File extension matches";
  } else {
    return "File extension does not match";
  }
}

// Приклади виклику функції:
console.log(checkFileExtension("styles.css", ".css")); // "File extension matches"
console.log(checkFileExtension("styles.css", ".js")); // "File extension does not match"
console.log(checkFileExtension("app.js", ".js")); // "File extension matches"
console.log(checkFileExtension("app.js", ".html")); // "File extension does not match"
console.log(checkFileExtension("index.html", ".html")); // "File extension matches"
console.log(checkFileExtension("index.html", ".css")); // "File extension does not match"
console.log(checkFileExtension("index.html", ".js")); // "File extension does not match"
      </code>
        </pre>
        <h3>Метод indexOf()</h3>
        <p>
          Метод indexOf() використовується для пошуку першого входження підрядка
          в рядок. Він повертає:
        </p>
        <p>
          індекс першого входження (індекс першого символу) підрядка, якщо він
          знайдений
        </p>
        <p>або -1, якщо підрядок не виявлено</p>
        <pre>
      <code>
const message = "Welcome to Bahamas!";
const index = message.indexOf("to");
console.log(index); // 8
      </code>
        </pre>
        <pre>
        <code>
const message = "Welcome to Bahamas!";
const index = message.indexOf("hello");
console.log(index); // -1
      </code>
        </pre>
        <p>Функція getFileName(file) приймає один параметр</p>

        <p>file - рядок з іменем файлу.</p>
        <p>
          Ім'я файлу може бути з розширенням, наприклад: styles.css, app.js або
          без, наприклад: styles, app.
        </p>
        <p>
          Використовуючи методи indexOf та slice, доповни код функції таким
          чином, щоб:
        </p>

        <p>
          Вона перевіряла наявність розширення в імені файлу (назва розширення
          відокремлюється від імені файла крапкою)
        </p>
        <p>
          Якщо ім'я файлу не містить розширення, то функція повертала новий
          підрядок, що містить ім'я файлу без змін
        </p>
        <p>
          В іншому разі функція повертала підрядок з іменем файлу, але без
          розширення
        </p>
        <pre>
      <code>
function getFileName(file) {
  const dotIndex = file.indexOf('.'); // Знаходимо позицію першої крапки в імені файлу
  
  if (dotIndex === -1) {
    return file; // Якщо крапки немає, повертаємо ім'я файлу без змін
  } else {
    return file.slice(0, dotIndex); // Якщо крапка є, повертаємо частину рядка до крапки
  }
}

// Приклади виклику функції:
console.log(getFileName("styles.css")); // "styles"
console.log(getFileName("app.js")); // "app"
console.log(getFileName("app")); // "app"
console.log(getFileName("index.js")); // "index"
console.log(getFileName("index.html")); // "index"
console.log(getFileName("index.css")); // "index"
console.log(getFileName("index")); // "index"
      </code>
        </pre>
        <h3>Метод trim()</h3>
        <p>
          Метод trim() використовується для видалення початкових і кінцевих
          пробілів із рядка.
        </p>
        <pre>
      <code>
const input = " JavaScript is awesome!    ";
const trimmedInput = input.trim();
console.log(trimmedInput); // "JavaScript is awesome!"
console.log(input); // " JavaScript is awesome! 
      </code>
        </pre>
        <p>Функція createFileName(name, ext) приймає два параметри:</p>

        <p>
          name - рядок, що зберігає ім'я файлу без розширення, яке вводить
          користувач. Воно може містити зайві пробіли на початку або в кінці
          рядка, наприклад "order ", " finance " тощо
        </p>
        <p>ext - рядок, що зберігає розширення, наприклад "txt", "xml" тощо</p>
        <p>
          Використовуючи синтаксис шаблонних рядків і метод trim(), доповни код
          функції таким чином, щоб вона повертала повне (об'єднане) ім'я файлу з
          доданим розширенням, зазначеним у параметрі ext у форматі
          ім'я.розширення.
        </p>
        <p>
          Також повне ім'я файлу не повинно містити зайвих пробілів на початку
          або наприкінці.
        </p>
        <pre>
      <code>
function createFileName(name, ext) {
  return `${name.trim()}.${ext}`;
}

// Приклади виклику функції:
console.log(createFileName(" order ", "txt")); // "order.txt"
console.log(createFileName("report ", "csv")); // "report.csv"
console.log(createFileName(" presentation", "xml")); // "presentation.xml"
      </code>
        </pre>
        <h2>Цикли</h2>
        <ul>
          <li>
            <dfn>Цикл</dfn> — керуюча конструкція, призначена для організації
            багаторазового виконання набору інструкцій.
          </li>
          <li>
            <dfn>Тіло циклу</dfn> — послідовність інструкцій, призначена для
            багаторазового виконання.
          </li>
          <li><dfn>Ітерація</dfn> — одиничне виконання тіла циклу.</li>
          <li>
            <dfn>Умова виходу</dfn> — вираз, що визначає, чи буде в черговий раз
            виконуватися ітерація, або цикл завершиться.
          </li>
        </ul>
        <h3>Цикл while</h3>
        <p>
          Конструкція while створює цикл, який виконує блок коду в тілі циклу,
          поки умова для виходу оцінюється як true.
        </p>
        <pre>
      <code>
while (condition) {
  statement // код, тіло циклу
}
      </code>
        </pre>
        <p>
          Умова обчислюється перед кожною ітерацією циклу. Якщо умова оцінюється
          як <code>true</code>, виконується код у тілі циклу (одна ітерація)
          Якщо умова оцінюється як <code>false</code>, виконання циклу
          переривається і скрипт продовжує виконувати інструкції після циклу
        </p>

        <p>
          <dfn>Цикл while</dfn> — це цикл з передумовою, тобто він виконується
          доки істинна певна умова, зазначена перед його початком. Цю умову
          перевіряють до виконання тіла циклу, тому тіло може бути не виконано
          жодного разу, якщо умова від самого початку хибна. Розгляньмо приклад
          з лічильником:
        </p>
        <pre>
      <code>
let count = 0;

while (count &lt; 10) {
  console.log(`Count: ${count}`);
  count += 1;
}
      </code>
        </pre>
        <p>
          У цьому прикладі у нас є змінна <code>count</code>, яка збільшується з
          кожною ітерацією. Цикл <code>while</code> виконуватиметься доки
          <code>count</code> менше <code>10</code>. Щойно count стане рівним або
          більшим за 10, умова стане хибною, і цикл завершиться.
        </p>
        <h4>Задача: Реєстрація у готелі</h4>
        <p>
          Змінна <code>clientCounter</code> зберігає кількість зайнятих номерів
          на поточний момент. Змінна <code>maxClients</code> зберігає загальну
          кількість номерів у готелі. Завдяки циклу <code>while</code> місця в
          готелі будуть заповнюватися доти, доки поточна кількість клієнтів не
          дорівнюватиме максимально допустимій.
        </p>
        <pre>
      <code>
let clientCounter = 18;
const maxClients = 25;

while (clientCounter &lt; maxClients) {
  console.log(clientCounter);
  clientCounter += 1;
}
      </code>
        </pre>
        <p>
          Цикл <code>while</code> часто використовується, коли точна кількість
          ітерацій заздалегідь не відома. Отже, цикл має виконуватися до
          виконання певної умови.
        </p>
        <h4></h4>
        <p>function calculateTotal(number) {}</p>
        <p>
          Функція calculateTotal(number) приймає ціле число (параметр number).
          Доповни код функції так, щоб вона повертала суму всіх цілих чисел від
          одиниці до цього числа включно. Наприклад, якщо number дорівнює 3, то
          сума - це 1 + 2 + 3, тобто 6.
        </p>

        <pre>
      <code>
let clientCounter = 18;
const maxClients = 25;

while (clientCounter &lt; maxClients) {
  console.log(clientCounter);
  clientCounter += 1;
}

console.log(calculateTotal(1));  // Виведе: 1
console.log(calculateTotal(3));  // Виведе: 6
console.log(calculateTotal(0));  // Виведе: 0
console.log(calculateTotal(18)); // Виведе: 171
console.log(calculateTotal(24)); // Виведе: 300
      </code>
        </pre>
        <p>
          Пояснення: <code>Ініціалізуємо</code> змінну sum значенням 0, яка буде
          зберігати підсумкову суму. Використовуємо цикл <code>for</code>, який
          починається з <code>1</code> і триває до <code>number</code>, додаючи
          кожне значення до <code>sum</code>. Після завершення циклу, функція
          повертає значення <code>sum</code>.
        </p>
        <h3>Цикл do…while</h3>
        <p>
          Цикли <code>while</code> і <code>do...while</code> працюють схожим
          чином, але мають одну ключову відмінність. Під час використання циклу
          <code>do...while</code> код у тілі циклу виконується принаймні один
          раз, навіть якщо умова не виконується з самого початку.
        </p>
        <pre>
      <code>
do {
   statement // код, який буде виконуватися
} while (condition);
      </code>
        </pre>
        <p>
          Блок коду всередині <code>do</code> виконується в перший раз незалежно
          від виконання умови. Потім, після кожної ітерації, перевіряється
          умова. Якщо умова оцінюється як <code>true</code>, цикл продовжує
          виконуватися; якщо — як <code>false</code>, цикл завершується.
          Розгляньмо приклад:
        </p>
        <pre>
      <code>
let count = 0;

do {
	console.log(`Count: ${count}`);
	count += 1;
} while (count &lt; 5);
      </code>
        </pre>
        <h3>Цикл for</h3>
        <p>
          На відміну від циклів <code>while</code> і <code>do…while</code>, цикл
          <code>for</code> має змінну-лічильник. Змінна-лічильник оголошується
          за допомогою ключового слова <code>let</code> (оголошення через
          <code>const</code> видасть помилку). На кожній ітерації після
          виконання коду з тіла циклу вона змінює своє значення від заданого
          початкового до кінцевого з певним кроком.
        </p>
        <pre>
      <code>
let count = 0;

do {
	console.log(`Count: ${count}`);
	count += 1;
} while (count &lt; 5);
      </code>
        </pre>
        <p>
          <dfn>Ініціалізація</dfn> — виконується один раз перед початком циклу.
          Тут оголошується змінна-лічильник і вказується її початкове значення.
        </p>
        <p>
          <dfn>Умова</dfn> — це вираз, який оцінюється перед кожною ітерацією
          (повторенням) циклу. Якщо умова перетворюється на**true**, то
          виконується тіло циклу. Якщо умова перетворюється на false, то цикл
          завершується.
        </p>
        <p>
          <dfn>Пост-вираз</dfn> — це вираз, який виконується в кінці кожної
          ітерації циклу, перед перевіркою умови. Використовується для оновлення
          значення змінної-лічильника.
        </p>
        <p>
          <dfn>Тіло циклу</dfn> — це блок коду, який буде виконуватися на кожній
          ітерації циклу, якщо умова перетворюється на true.
        </p>
        <pre>
      <code>
for (let i = 0; i &lt;= 20; i += 5) {
  console.log(i);
}
      </code>
        </pre>
        <p>
          У наведеному прикладі циклу <dfn>for</dfn> змінна i ініціалізується
          значенням <dfn>0</dfn>. Цикл виконується доти, доки i менша або
          дорівнює <dfn>20</dfn>. Після кожної ітерації значення i збільшується
          на <dfn>5</dfn>. У результаті в консоль будуть виведені числа
          <dfn>0, 5, 10, 15</dfn> і <dfn>20</dfn>.
        </p>
        <pre>
      <code>
for (let i = 20; i >= 0; i -= 5) {
  console.log(i);
}
      </code>
        </pre>
        <p>
          У наведеному прикладі циклу <dfn>for</dfn> змінна i ініціалізується
          значенням <dfn>20</dfn>. Цикл виконується доти, доки i більше або
          дорівнює <dfn>0</dfn>. Після кожної ітерації значення i зменшується на
          <dfn>5</dfn>. У результаті в консоль будуть виведені числа
          <dfn>20, 15, 10, 5</dfn> і <dfn>0</dfn>.
        </p>
        <h2>Інкремент і декремент</h2>
        <p>
          Інкремент (<code>++</code>) і декремент (<code>--</code>) — це
          операції, які відповідно збільшують або зменшують значення числової
          змінної на одиницю і одразу ж зберігають оновлене значення у цій
          змінній. Існують два види інкременту та декременту: префіксний і
          постфіксний.
        </p>
        <p>
          <dfn>Префіксний інкремент</dfn> (<code>++value</code>) спочатку
          збільшує значення змінної, а потім використовує нове значення у
          виразі.
        </p>
        <pre>
      <code>
let x = 5;
const y = ++x;
console.log(x); // 6
console.log(y); // 6
      </code>
        </pre>
        <p>
          <dfn>Постфіксний інкремент</dfn> (<code>value++</code>) спочатку
          використовує поточне значення змінної у виразі, а потім виконує
          збільшення значення.
        </p>
        <pre>
      <code>
let x = 5;
const y = x++;
console.log(x); // 6
console.log(y); // 5
      </code>
        </pre>
        <p>
          <dfn>Префіксний декремент</dfn> (<code>--value</code>) спочатку
          зменшує значення змінної, а потім використовує нове значення у виразі.
        </p>
        <pre>
      <code>
let x = 5;
const y = --x;
console.log(x); // 4
console.log(y); // 4
      </code>
        </pre>
        <p>
          <dfn>Постфіксний декремент</dfn> (<code>value--</code>) спочатку
          використовує поточне значення змінної у виразі, а потім виконує
          зменшення значення.
        </p>
        <pre>
        <code>
let x = 5;
const y = x--;
console.log(x); // 4
console.log(y); // 5
      </code>
        </pre>
        <p>
          Ці операції корисні, коли потрібно змінювати значення змінних одразу
          на одиницю, що може бути важливо, наприклад, при створенні лічильників
          у циклах, замість комбінованих операторів <code>+=</code> і
          <code>-=</code>.
        </p>
        <pre>
        <code>
for (let i = 0; i &lt;= 5; i++) {
  console.log(i);
}
      </code>
        </pre>
        <p>
          У прикладі циклу for вище, змінна i ініціалізується значенням
          <code>0</code>, і цикл виконується доти, доки i менше або дорівнює
          <code>5</code>. Після кожної ітерації значення i збільшується на
          <code>1</code>. У результаті в консоль будуть виведені числа від
          <code>0</code> до <code>5</code>.
        </p>
        <h4>Задача</h4>
        <p>
          Функція <code>calculateEvenTotal(number)</code> приймає ціле число
          (параметр <code>number</code>). Доповни код функції так, щоб вона
          повертала суму всіх парних цілих чисел від одиниці до цього числа
          включно. Парні числа — це ті, що можна поділити на 2 без остачі.
          Наприклад, якщо number дорівнює 6, то сума - це 2 + 4 + 6, тобто 12.
        </p>
        <pre>
        <code>
function calculateEvenTotal(number) {
  let sum = 0;
  for (let i = 1; i &lt;= number; i += 1) {
    if (i % 2 === 0) {
      sum += i;
    }
  }
  return sum;
}
      </code>
        </pre>
        <p><b>Як працює цей код:</b></p>
        <p>
          <b>Змінна sum:</b> Спочатку оголошується змінна <code>sum</code>, яка
          буде накопичувати суму всіх парних чисел. Початкове значення —
          <code>0</code>.
        </p>
        <p>
          <b>Цикл for:</b> Використовується цикл <code>for</code>, який
          перебирає всі числа від <code>1</code> до <code>number</code> включно.
          З кожним проходом цикл збільшує змінну <code>i</code> на
          <code>1</code>.
        </p>
        <p>
          <b>Перевірка на парність:</b> Всередині циклу перевіряється, чи є
          число парним за допомогою виразу <code>i % 2 === 0</code>. Оператор
          <code>%</code> (остача від ділення) використовується для перевірки, чи
          ділиться число на <code>2</code> без остачі. Якщо число парне, воно
          додається до змінної <code>sum</code>.
        </p>
        <p>
          <b>Повернення результату:</b> Після завершення циклу функція повертає
          загальну суму всіх парних чисел від 1 до number.
        </p>
        <p>Приклади використання:</p>
        <p>
          <code>calculateEvenTotal(1)</code> поверне <code>0</code>, оскільки
          немає парних чисел від <code>1</code>.
        </p>
        <p>
          <code>calculateEvenTotal(3)</code> поверне <code>2</code>, оскільки
          єдине парне число між <code>1</code> і <code>3</code> — це
          <code>2</code>.
        </p>
        <p>
          <code>calculateEvenTotal(6)</code> поверне <code>12</code>, оскільки
          сума парних чисел <code>2 + 4 + 6</code> дорівнює <code>12</code>.
        </p>
        <p>
          <code>calculateEvenTotal(18)</code> поверне <code>90</code>, сума
          парних чисел від <code>2</code> до <code>18</code>.
        </p>
        <h3>Оператор break</h3>
        <p>
          Оператор <code>break</code> використовується в циклі для переривання
          його виконання. Коли оператор break зустрічається всередині циклу,
          виконання циклу негайно припиняється, і керування передається до
          наступної інструкції після циклу.
        </p>
        <p>
          Оператор <code>break</code> зазвичай використовується разом з умовними
          операторами або операторами порівняння всередині циклу, щоб перевіряти
          певну умову і, якщо вона виконується, переривати виконання циклу.
        </p>

        <pre>
        <code>
for (let i = 0; i &lt; 10; i+=1) {
  console.log(i);

  if (i === 5) {
    console.log('Met the number 5, interrupt the execution of the cycle');
    break;
  }
}

console.log('Log after cycle');
      </code>
        </pre>
        <p>
          У цьому прикладі цикл <code>for</code> мав би виконуватися, доки
          значення змінної i менше <code>10</code>. Але в тілі циклу є умова
          <code>if (i === 5)</code>, яка перевіряє, чи дорівнює значення
          <code>i</code> числу <code>5</code>. Коли ця умова стає істинною, тіло
          <code>if</code> виконується і застосовується оператор
          <code>break</code>, і виконання циклу припиняється. Таким чином, у
          консоль будуть виведені числа від <code>0</code> до
          <code>5</code> (включно), а цикл завершиться.
        </p>
        <p>What a difficult language. Why not just speak English?</p>

        <h4>Задача</h4>
        <p>
          Доповни код таким чином, щоб у змінну <code>number</code> записувалося
          перше число у проміжку від <code>start</code> до <code>end</code>, яке
          ділиться на <code>5</code> без остачі.
        </p>
        <pre>
        <code>
const start = 6;
const end = 17;
let number;

for (let i = start; i &lt;= end; i += 1) {
  if (i % 5 === 0) {
    number = i;
    break;
  }
}

console.log(number); // 10
      </code>
        </pre>
        <h3>Оператор break і функції</h3>
        <p>
          Коли оператор <code>break</code> зустрічається всередині циклу,
          виконання циклу негайно припиняється, і керування передається на
          наступну інструкцію за циклом, навіть якщо цикл знаходиться всередині
          функції. Тобто оператор <code>break</code> не припиняє виконання
          функції, а тільки перериває цикл.
        </p>
        <pre>
        <code>
function findNumberFromFive(max, target) {
	console.log("Log in the body of the function before the cycle");

  for (let i = 5; i &lt;= max; i += 1) {
    console.log("Current counter value i:", i);

    if (i === target) {
      console.log(`Found the number $ {target}, interrupt the cycle`);
			break;
    }
  }

  console.log("Log in body function after cycle");
}

findNumber(10, 6);
console.log("Log after exiting function");
      </code>
        </pre>
        <p>
          Для того щоб переривати виконання одразу циклу і функції і повернути
          результат у зовнішній код, є оператор <code>return</code>. У прикладі
          шукаємо число <code>6</code>. Щойно виконається умова <code>if</code>,
          робимо повернення, яке перерве виконання циклу і функції.
        </p>
        <pre>
        <code>
function findNumberFromFive(max, target) {
	console.log("Log in the body of the function before the cycle");

	for (let i = 5; i &lt;= max; i += 1) {
	    console.log("Current counter value i:", i);
	
	    if (i === target) {
	      console.log(`Found the number $ {target}, we make a return, interrupting the loop and function`);
				return i;
	    }
	  }

  // Цей console.log не виконується
  console.log("Log in body function after cycle");
}

const result = findNumber(10, 6);
console.log("Log after exiting function");
console.log(`Result of function execution ${result}`);
      </code>
        </pre>
      </div>
    </section>

    <section>
      <div class="container">
        <h2>Масиви. Arrays.</h2>
        <p>
          <dfn>Масив</dfn> — це впорядкована структура даних, яка
          використовується для зберігання колекції елементів, та можуть містити
          елементи різних типів даних (числа, рядки, булеві значення тощо). Для
          створення масиву в JavaScript використовується літерал масиву:
          квадратні дужки <code>[]</code>. Усередині дужок перераховуються
          елементи масиву, розділені комами.
        </p>

        <pre>
        <code>
const planets = ['Earth', 'Mars', 'Venus']; // масив рядків
const numbers = [1, 2, 3, 4, 5]; // масив чисел
      </code>
        </pre>
        <p>Масиви також можуть містити елементи різних типів даних.</p>
        <pre>
        <code>
const mixed = ['apple', 10, true]; // масив з елементами різних типів
      </code>
        </pre>
        <h3>Перевизначення значення елемента масиву</h3>
        <p>
          Елементи масиву можна змінювати, звернувшись до них за індексом і
          присвоївши нове значення. Цей процес називається "перевизначенням"
          значення елемента.
        </p>
        <pre>
        <code>
const planets = ['Earth', 'Mars', 'Venus', 'Uranus'];
planets[0] = 'Jupiter';
planets[2] = 'Neptune';
console.log(planets); // ['Jupiter', 'Mars', 'Neptune', 'Uranus']
      </code>
        </pre>
        <h3>Довжина масиву</h3>
        <p>
          Довжина масиву, тобто кількість його елементів, зберігається у
          властивості <code>length</code>. Це динамічна величина, яка
          автоматично змінюється під час додавання або видалення елементів.
        </p>
        <pre>
        <code>
const planets = ['Earth', 'Mars', 'Venus'];
console.log(planets.length); // 3
      </code>
        </pre>
        <p>
          Знання довжини масиву корисно, коли нам потрібно перевірити, скільки
          елементів у масиві на даний момент.
        </p>
        <pre>
        <code>
const planets = ['Earth', 'Mars', 'Venus'];

if(planets.length >= 3) {
	console.log("3 or more elements");
} else {
	console.log("3 or less elements");
}
      </code>
        </pre>
        <p>
          Функція <code>getOrderQuantity(order)</code> приймає один параметр
          order - масив рядків, які описують продукти в замовленні клієнта.
          Доповни код функції таким чином, щоб вона повертала число, що дорівнює
          кількості елементів масиву.
        </p>
        <p>Оголошена функція getOrderQuantity(order) Виклик</p>
        <p>
          getOrderQuantity(["apple", "peach", "pear", "banana"]) повертає 4
          Виклик
        </p>
        <p>getOrderQuantity(["apple", "banana"]) повертає 2 Виклик</p>
        <p>getOrderQuantity(["apple", "banana", "pear"]) повертає 3 Виклик</p>
        <p>getOrderQuantity([]) повертає 0</p>
        <p>
          Щоб функція getOrderQuantity(order) повертала кількість елементів
          масиву, можна скористатися властивістю length, яка повертає довжину
          масиву. Ось як це можна зробити:
        </p>
        <pre>
        <code>
function getOrderQuantity(order) {
  return order.length;
}

console.log(getOrderQuantity(["apple", "peach", "pear", "banana"])); // 4
console.log(getOrderQuantity(["apple", "banana"])); // 2
console.log(getOrderQuantity(["apple", "banana", "pear"])); // 3
console.log(getOrderQuantity([])); // 0
      </code>
        </pre>
        <h3>Індекс останнього елемента</h3>
        <p>
          Оскільки індексація елементів масиву починається з 0, а довжина масиву
          зберігає загальну кількість елементів, віднімаючи 1 від довжини
          масиву, ми отримуємо індекс останнього елемента.
        </p>
        <pre>
        <code>
const planets = ["Earth", "Mars", "Venus"];
const lastElementIndex = planets.length - 1;
console.log(planets[lastElementIndex]); // "Venus"
      </code>
        </pre>
        <p>
          У цьому прикладі маємо масив <code>planets</code> із трьома
          елементами. Щоб отримати індекс останнього елемента масиву
          оголошується змінна <code>lastElementIndex</code> зі значенням
          <code>planets.length - 1</code>. Маючи індекс останнього елемента в
          масиві, можемо отримати його значення за допомогою
          <code>planets[lastElementIndex]</code>.
        </p>

        <p>
          Функція getLastElementMeta(array) приймає один параметр array - масив
          довільних значень. Доповни код функції таким чином, щоб вона повертала
          новий масив з двох елементів:
        </p>

        <p>перший елемент - це індекс останнього елементу у масиві array</p>
        <p>другий елемент - це значення останнього елементу у масиві array</p>
        <pre>
<code>
Оголошена функція getLastElementMeta(array)
Виклик getLastElementMeta(["apple", "peach", "pear", "banana"]) повертає [3, "banana"]
Виклик getLastElementMeta(["apple", "peach", "pear"]) повертає [2, "pear"]
Виклик getLastElementMeta(["apple", "peach"]) повертає [1, "peach"]
Виклик getLastElementMeta(["apple"]) повертає [0, "apple"]
</code>
        </pre>
        <pre>
<code>
function getLastElementMeta(array) {
  const lastIndex = array.length - 1; // Індекс останнього елемента
  const lastElement = array[lastIndex]; // Значення останнього елемента
  return [lastIndex, lastElement]; // Повертаємо масив з індексом та значенням
}

console.log(getLastElementMeta(["apple", "peach", "pear", "banana"])); // [3, "banana"]
console.log(getLastElementMeta(["apple", "peach", "pear"])); // [2, "pear"]
console.log(getLastElementMeta(["apple", "peach"])); // [1, "peach"]
console.log(getLastElementMeta(["apple"])); // [0, "apple"]
</code>

        </pre>
        <pre>
<code>
function getExtremeElements(array) {}
</code>
        </pre>

        <p>
          Функція getExtremeElements(array) приймає один параметр array - масив
          елементів довільної довжини. Доповни код функції таким чином, щоб вона
          повертала масив з двох елементів - першого і останнього елементів
          параметра array.
        </p>
        <pre>
<code>
Оголошена функція getExtremeElements(array)
Виклик getExtremeElements([1, 2, 3, 4, 5]) повертає [1, 5]
Виклик getExtremeElements(["Earth", "Mars", "Venus"]) повертає ["Earth", "Venus"]
Виклик getExtremeElements(["apple", "peach", "pear", "banana"]) повертає ["apple", "banana"]
</code>
        </pre>

        <p>
          Щоб реалізувати функцію getExtremeElements, потрібно витягнути перший
          і останній елемент з масиву і повернути їх у новому масиві. Ось як це
          можна зробити:
        </p>
        <pre>
<code>
function getExtremeElements(array) {
  // Повертаємо новий масив з першим та останнім елементами
  return [array[0], array[array.length - 1]];
}
</code>
        </pre>
        <p>Присвоєння за посиланням і за значенням</p>
        <p>
          Фундаментальною відмінністю складних типів від примітивів є те, як
          вони зберігаються і копіюються.
        </p>
        <p>
          Примітиви: <mark>рядки, числа, буль, null</mark> і
          <mark>undefined</mark>, під час присвоювання копіюються цілком, за
          значенням (<code>by value</code>).
        </p>
        <p>
          Під час присвоєння за значенням змінним виділяється новий осередок
          пам'яті, і в нього копіюються дані.
        </p>
        <p>
          При присвоєнні за посиланням, замість створення нового значення,
          змінній присвоюється посилання (покажчик) на вже існуючий масив, тобто
          на його місце в пам'яті. Таким чином, кілька змінних можуть вказувати
          на один і той самий масив.
        </p>
        <pre>
<code>
let a = 5;

let b = a;
console.log(a); // 5
console.log(b); // 5
// Присвоєння за значенням, у пам'яті буде створено ще
// одну ячейку, в яку буде скопійовано значення 5

// Змінимо значення a
a = 10;
console.log(a); // 10
console.log(b); // 5 Значення b не змінилося, оскільки це окрема копія
</code>
        </pre>
        <p>
          Масиви (складний тип) присвоюються за посиланням, тобто змінна просто
          отримує посилання (покажчик у пам'яті) на вже існуючий масив.
        </p>
        <pre>
<code>
const a = ["Mango", "Poly"];
const b = a;
console.log(a); // ["Mango", "Poly"]
console.log(b); // ["Mango", "Poly"]
</code>
        </pre>
        <p>
          Оскільки <code>a</code> це масив, у <code>b</code> записується
          посилання на вже наявний у пам'яті масив. Тепер <code>a</code> і
          <code>b</code> вказують на один і той самий масив.
        </p>
        <p>
          Змінимо масив, замінивши елемент з індексом <code>1</code>,
          використовуючи посилання з <code>a</code>.
        </p>
        <pre>
<code>
const a = ["Mango", "Poly"];
const b = a;
console.log(a); // ["Mango", "Poly"]
console.log(b); // ["Mango", "Poly"]

a[1] = "Jacob";
console.log(a); // ["Mango", "Jacob"]
console.log(b); // ["Mango", "Jacob"]
</code>
        </pre>
        <p>
          Результат повторюється, якщо використовувати посилання у змінній b для
          зміни масиву.
        </p>
        <pre>
<code>
const a = ["Mango", "Poly"];
const b = a;
console.log(a); // ["Mango", "Poly"]
console.log(b); // ["Mango", "Poly"]

a[1] = "Jacob";
console.log(a); // ["Mango", "Jacob"]
console.log(b); // ["Mango", "Jacob"]

b[0] = "Ajax";
console.log(a); // ["Ajax", "Jacob"]
console.log(b); // ["Ajax", "Jacob"]
</code>
        </pre>
        <p>
          Два масиви ніколи не дорівнюють один одному, навіть якщо вони порожні
          або в них однакові елементи.
        </p>
        <pre>
<code>
const arr1 = [1, 2, 3];
const arr2 = [1, 2, 3];

console.log(arr1 === arr2); // false
console.log([] === []); // false
</code>
        </pre>
        <h3>Приведення типів: масиви</h3>
        <p>
          Явне і не явне приведення типів масивів здійснюється за необхідності
          виконати операції або порівняння, які вимагають сумісності типів
          даних.
        </p>
        <h4>Масив → Рядок</h4>
        <p>
          При перетворенні масиву в рядок усі елементи масиву об'єднуються в
          один рядок, розділений комами.
        </p>
        <pre>
<code>
const array = [1, true, "Poly"];
console.log(String(array));// "1,true,Poly"
console.log(array + "5"); // "1,true,Poly5"
</code>
        </pre>
        <h4>Змінні (Variables)</h4>
        <p>
          <code>var</code>, <code>let</code>, <code>const</code>: ключові слова
          для оголошення змінних. <code>var</code> використовувався раніше, але
          тепер переважно використовують <code>let</code> і const через їхні
          переваги щодо областей видимості та незмінності (у випадку
          <code>const</code>).
        </p>

        <h4>Масив → Число</h4>
        <p>
          При перетворенні масиву в число алгоритм складається з двох кроків:
          спочатку масив приводиться до рядка, а потім цей рядок приводиться до
          числового значення.
        </p>
        <pre>
<code>
console.log(Number([])); // 0
console.log(Number([1])); // 1
console.log(Number([1, 2, 3])); // NaN
</code>
        </pre>
        <h4>Масив → Логічне значення (буль)</h4>
        <pre>
<code>
const emptyArray = [];
const nonEmptyArray = [1, 2, 3];

console.log(Boolean(emptyArray)); // true
console.log(Boolean(nonEmptyArray)); // true

if(emptyArray) {
	console.log("if is in progress")
} else {
	console.log("else is not performed")
}

if(nonEmptyArray) {
	console.log("if is in progress")
} else {
	console.log("else is not performed")
}

</code>
        </pre>
        <h3>Методи масиву</h3>
        <p>
          У масивів є вбудовані методи, які дозволяють виконувати операції для
          роботи з елементами масиву.
        </p>
        <h4>Метод join()</h4>
        <p>
          Метод масиву <code>join(delimiter)</code> дозволяє об'єднати елементи
          масиву в рядок. У результуючому рядку елементи будуть розділені
          символом або групою символів, зазначених у <code>delimiter</code>.
        </p>
        <pre>
<code>
const words = ["JavaScript", "is", "amazing"];
console.log(words.join("")); // 'JavaScriptisamazing'
console.log(words.join(" ")); // 'JavaScript is amazing'
console.log(words.join("-")); // 'JavaScript-is-amazing'
</code>
        </pre>
        <p>
          Результат роботи методу можна зберегти у змінну для подальшого
          використання.
        </p>
        <p>
          Наприклад, нам потрібно написати функцію, яка перетворює рядки зі
          <code>snake_case</code> (зміїної нотації з підкресленнями) в
          <code>kebab-case</code> (нотацію з тире).
        </p>
        <pre>
<code>
function transformString(string) {
	const words = string.split("_");
	return words.join("-");
}

transformString("user_age"); // "user-age"
transformString("price_per_droid"); // "price-per-droid"
</code>
        </pre>
        <!-- Завдання -->
        <p>
          Функція getLength(array) очікує один параметр array - масив довільних
          значень. Доповни код функції так, щоб вона перетворювала масив у
          рядок, без роздільників, і повертала кількість символів в отриманому
          рядку.
        </p>

        <p>Оголошена функція <code>getLength(array)</code></p>
        <p>
          Виклик
          <code>getLength(["Mango", "hurries", "to", "the", "train"])</code>
          повертає
          <code>22</code>
        </p>
        <p>
          Виклик <code>getLength(["M", "a", "n", "g", "o"])</code> повертає
          <code>5</code>
        </p>
        <p>
          Виклик <code>getLength(["top", "picks", "for", "you"])</code> повертає
          <code>14</code>
        </p>
        <pre>
<code>
function getLength(array) {
  // Перетворюємо масив у рядок без роздільників за допомогою join('')
  const string = array.join('');
  
  // Повертаємо кількість символів у отриманому рядку
  return string.length;
}

// Приклади використання
console.log(getLength(["Mango", "hurries", "to", "the", "train"])); // 22
console.log(getLength(["M", "a", "n", "g", "o"])); // 5
console.log(getLength(["top", "picks", "for", "you"])); // 14
</code>
        </pre>
        <p>Пояснення:</p>
        <p>
          <code>array.join('')</code> перетворює масив у рядок, об'єднуючи всі
          елементи без роздільників. Наприклад,
          <code>["Mango", "hurries", "to", "the", "train"]</code> перетворюється
          в <code>"Mangohurriestothetrain"</code>.
        </p>
        <p>
          <code>string.length</code> повертає кількість символів у цьому рядку.
        </p>
        <p>
          Таким чином, функція повертає довжину рядка, який був створений з
          елементів масиву.
        </p>
        <h4>Метод split()</h4>
        <p>
          Метод рядків <code>split(delimiter)</code> виконує зворотну операцію
          порівняно з методом масивів <code>join(delimiter)</code>. Він дозволяє
          перетворити рядок на масив, розбивши його за вказаним роздільником
          <code>delimiter</code>.
        </p>
        <p>
          Якщо роздільник є порожнім рядком (рядком, у якому нема символів), то
          вийде масив окремих символів рядка. Роздільником може бути один або
          кілька символів. Результат роботи методу можна зберегти у змінну для
          подальшого використання.
        </p>
        <pre>
<code>
const name = "Mango";
const letters = name.split("");
console.log(letters); // ["M", "a", "n", "g", "o"]

const message = "JavaScript essentials";
const words = message.split(" ");
console.log(words); // ["JavaScript", "essentials"]

const slug = "amazing-french-recipes";
const slugParts = slug.split("-");
console.log(slugParts); // ["amazing", "french", "recipes"]
</code>
        </pre>
        <p>
          У першому прикладі рядок "Mango" було перетворено на масив, де кожна
          літера стала окремим елементом масиву. Роздільником було вказано
          порожній рядок.
        </p>
        <p>
          У другому прикладі рядок "JavaScript essentials" було розділено на два
          елементи масиву, використовуючи пробіл як роздільник.
        </p>
        <p>
          У третьому прикладі рядок "amazing-french-recipes" було розділено на
          три елементи масиву, використовуючи тире як роздільник.
        </p>
        <p>
          Сервісу гравірування прикрас потрібна функція, яка б автоматично
          рахувала ціну гравірування, залежно від кількості слів і ціни за
          слово.
        </p>
        <!-- Завдання -->
        <p>
          Оголошена функція
          <code>calculateEngravingPrice(message, pricePerWord)</code>. Ця
          функція приймає першим параметром рядок, що складається зі слів,
          розділених лише пробілами (параметр <code>message</code>) та другим
          параметром - число, що містить ціну гравірування за одне слово
          (параметр <code>pricePerWord</code>).
        </p>
        <p>
          Доповни тіло функції так, щоб вона повертала загальну вартість
          гравірування усіх слів в рядку.
        </p>
        <p>
          Оголошена функція
          <code>calculateEngravingPrice(message, pricePerWord)</code>
        </p>
        <p>
          Виклик
          <code>calculateEngravingPrice("JavaScript is in my blood", 10)</code>
          повертає <code>50</code>
        </p>
        <p>
          Виклик
          <code>calculateEngravingPrice("JavaScript is in my blood", 20)</code>
          повертає <code>100</code>
        </p>
        <p>
          Виклик
          <code
            >calculateEngravingPrice("Web-development is creative work",
            40)</code
          >
          повертає <code>160</code>
        </p>
        <p>
          Виклик
          <code
            >calculateEngravingPrice("Web-development is creative work",
            20)</code
          >
          повертає <code>80</code>
        </p>
        <pre>
<code>
function calculateEngravingPrice(message, pricePerWord) {
  // Розбиваємо рядок на масив слів за допомогою split(' ')
  const words = message.split(' ');

  // Рахуємо загальну вартість гравірування
  const totalPrice = words.length * pricePerWord;

  // Повертаємо результат
  return totalPrice;
}

// Приклади використання
console.log(calculateEngravingPrice("JavaScript is in my blood", 10)); // 50
console.log(calculateEngravingPrice("JavaScript is in my blood", 20)); // 100
console.log(calculateEngravingPrice("Web-development is creative work", 40)); // 160
console.log(calculateEngravingPrice("Web-development is creative work", 20)); // 80
</code>
        </pre>
        <p>
          message.split(' ') розбиває рядок на масив слів, використовуючи пробіл
          як роздільник. Наприклад, "JavaScript is in my blood" перетворюється
          на ["JavaScript", "is", "in", "my", "blood"].
        </p>
        <p>words.length дає кількість слів у рядку.</p>
        <p>
          Загальна вартість гравірування обчислюється як кількість слів,
          помножена на ціну за одне слово.
        </p>
        <p>Результат повертається функцією.</p>

        <h4>Метод slice()</h4>
        <p>
          Метод масиву <code>slice(begin, end)</code> повертає новий масив, що
          містить копію частини вихідного масиву, не змінюючи його. Копія
          створюється від індексу <code>begin</code> до, але не включаючи індекс
          <code>end</code>.
        </p>
        <p>
          Метод slice() корисний, коли необхідно отримати підмасив із вихідного
          масиву або створити його копію для подальшої роботи з ним.
        </p>
        <pre>
<code>
const planets = ["Earth", "Mars", "Venus", "Jupiter", "Saturn"];
console.log(planets.slice(0, 2)); // ['Earth', 'Mars']
console.log(planets.slice(0, 4)); // ['Earth', 'Mars', 'Venus', 'Jupiter']
console.log(planets.slice(1, 3)); // ['Mars', 'Venus']
</code>
        </pre>
        <p>
          Результат роботи методу <code>slice()</code> можна зберегти у змінну
          для подальшого використання:
        </p>
        <pre>
<code>
const planets = ["Earth", "Mars", "Venus", "Jupiter", "Saturn"];
const result = planets.slice(1, 3);
console.log(result); // ["Mars", "Venus"]
</code>
        </pre>
        <p>
          Якщо не вказати параметри <code>begin</code> і <code>end</code>, буде
          створено повну копію вихідного масиву:
        </p>
        <pre>
<code>
const planets = ["Earth", "Mars", "Venus", "Jupiter", "Saturn"];
console.log(planets.slice()); // ["Earth", "Mars", "Venus", "Jupiter", "Saturn"]
</code>
        </pre>
        <p>
          Якщо не вказати <code>end</code>, копіювання відбуватиметься від
          <code>begin</code> до кінця масиву:
        </p>
        <pre>
<code>
const planets = ["Earth", "Mars", "Venus", "Jupiter", "Saturn"];
console.log(planets.slice(1)); // ["Mars", "Venus", "Jupiter", "Saturn"]
console.log(planets.slice(2)); // ["Venus", "Jupiter", "Saturn"]
</code>
        </pre>
        <p>
          Якщо значення <code>begin</code> негативне, а <code>end</code> не
          вказано, будуть скопійовані останні begin елементів (тобто стільки
          елементів з кінця, скільки вказано в параметрі begin):
        </p>
        <pre>
<code>
const planets = ["Earth", "Mars", "Venus", "Jupiter", "Saturn"];
console.log(planets.slice(-2)); // ["Jupiter", "Saturn"]
</code>
        </pre>
        <!-- Завдання -->
        <p>
          Доповни код таким чином, щоб змінні містили часткові копії вихідного
          масиву <code>fruits</code>.
        </p>
        <p><code>firstTwoEls</code> - масив із перших двох елементів</p>
        <p>
          <code>nonExtremeEls</code> - масив з усіх елементів, крім першого та
          останнього
        </p>
        <p><code>lastThreeEls</code> - масив із трьох останніх елементів</p>
        <p>Оголошена змінна fruits</p>
        <p>
          Значення змінної fruits - це масив ["apple", "plum", "pear", "orange",
          "banana"]
        </p>
        <p>Оголошена змінна firstTwoEls</p>
        <p>Значення змінної firstTwoEls - це масив ["apple", "plum"]</p>
        <p>Оголошена змінна nonExtremeEls</p>
        <p>
          Значення змінної nonExtremeEls - це масив ["plum", "pear", "orange"]
        </p>
        <p>Оголошена змінна lastThreeEls</p>
        <p>
          Значення змінної lastThreeEls - це масив ["pear", "orange", "banana"]
        </p>
        <pre>
<code>
const fruits = ['apple', 'plum', 'pear', 'orange', 'banana'];

const firstTwoEls = fruits.slice(0, 2);
const nonExtremeEls = fruits.slice(1, -1);
const lastThreeEls = fruits.slice(-3);

console.log(firstTwoEls); // ["apple", "plum"]
console.log(nonExtremeEls); // ["plum", "pear", "orange"]
console.log(lastThreeEls); // ["pear", "orange", "banana"]
</code>
        </pre>
        <p>
          <code>firstTwoEls</code> використовує <code>slice(0, 2)</code> для
          отримання масиву з перших двох елементів.
        </p>
        <p>
          <code>nonExtremeEls</code> використовує <code>slice(1, -1)</code> для
          отримання масиву, який виключає перший і останній елементи.
        </p>
        <p>
          <code>lastThreeEls</code> використовує <code>slice(-3)</code> для
          отримання масиву з трьох останніх елементів.
        </p>
        <h4>Метод concat()</h4>
        <p>
          Метод <code>concat(arr1, arr2, ..., arrN)</code> використовується для
          об'єднання двох або більше масивів.
        </p>
        <pre>
<code>
const firstArray = ["Mercury", "Venus"];
const secondArray = ["Mars", "Jupiter"];
const result = firstArray.concat(secondArray);

console.log(result); // ["Mercury", "Venus", "Mars", "Jupiter"];
</code>
        </pre>
        <p>
          Вихідні масиви <code>firstArray</code> і
          <code>secondArray</code> залишаються незмінними після виклику
          <code>concat()</code>. Метод <code>concat()</code> створює і повертає
          новий масив, що містить усі елементи об'єднаних масивів.
        </p>
        <pre>
<code>
const firstArray = ["Mercury", "Venus"];
const secondArray = ["Mars", "Jupiter"];
const result = firstArray.concat(secondArray);

console.log(firstArray); // ["Mercury", "Venus"];
console.log(secondArray); // ["Mars", "Jupiter"];
console.log(result); // ["Mercury", "Venus", "Mars", "Jupiter"];
</code>
        </pre>
        <p>
          Порядок аргументів методу визначає порядок розташування елементів у
          новому масиві.
        </p>
        <pre>
<code>
const firstArray = ["Mercury", "Venus"];
const secondArray = ["Mars", "Jupiter"];
const thirdArray = ["Saturn", "Neptune"];

console.log(firstArray.concat(secondArray, thirdArray)); 
// ['Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Neptune'];

console.log(firstArray.concat(thirdArray, secondArray)); 
// ['Mercury', 'Venus', 'Saturn', 'Neptune', 'Mars', 'Jupiter', ];
</code>
        </pre>
        <!-- Завдання -->
        <p>
          Оголоси змінну <code>>allClients</code> та доповни код таким чином,
          щоб її значенням було посилання на масив, що складається з усіх
          елементів масивів <code>oldClients</code> і <code>newClients</code>.
          Спочатку мають іти елементи з масива <code>oldClients</code>, а потім
          з <code>newClients</code>.
        </p>
        <p>Оголошена змінна <code>oldClients</code></p>
        <p>
          Значення змінної <code>oldClients</code> - це масив
          <code>["Mango", "Ajax", "Poly", "Kiwi"]</code>
        </p>
        <p>Оголошена змінна <code>newClients</code></p>
        <p>
          Значення змінної <code>newClients</code> - це масив
          <code>["Peach", "Houston"]</code>
        </p>
        <p>Оголошена змінна <code>allClients</code></p>
        <p>
          Значення змінної <code>allClients</code> - це масив
          <code>["Mango", "Ajax", "Poly", "Kiwi", "Peach", "Houston"]</code>
        </p>
        <p>
          Змінній <code>allClients</code> присвоєний масив після застосування
          методу concat з правильними аргументами
        </p>
        <pre>
<code>
const oldClients = ["Mango", "Ajax", "Poly", "Kiwi"];
const newClients = ["Peach", "Houston"];

const allClients = oldClients.concat(newClients);

console.log(allClients); // ["Mango", "Ajax", "Poly", "Kiwi", "Peach", "Houston"]
</code>
        </pre>
        <p>
          Метод <code>concat()</code> використовується для об'єднання двох або
          більше масивів.
        </p>
        <p>
          У цьому прикладі ми викликаємо
          <code>oldClients.concat(newClients)</code>, що створює новий масив,
          який спочатку містить всі елементи з oldClients, а потім додає всі
          елементи з newClients.
        </p>
        <p>
          Значення змінної <code>allClients</code> тепер є масивом, який
          складається з усіх клієнтів з обох масивів.
        </p>
        <h4>Метод indexOf()</h4>
        <p>
          Метод <code>масиву indexOf(elem)</code> використовується для
          визначення індексу першого входження елемента <code>elem</code> у
          масиві. Він повертає індекс елемента, якщо він знайдений, або
          <code>-1</code>, якщо елемент не знайдений. Метод
          <code>indexOf()</code> виконує сувору рівність <code>(===)</code> при
          порівнянні елементів.
        </p>
        <p>Синтаксис методу <code>indexOf()</code> має такий вигляд:</p>
        <pre>
<code>
array.indexOf(elem)
</code>
        </pre>
        <p><code>array</code> — масив, у якому здійснюється пошук.</p>
        <p>
          <code>elem</code> — елемент, індекс якого потрібно знайти в масиві.
        </p>
        <pre>
<code>
const clients = ["Mango", "Ajax", "Poly", "Kiwi", "Poly"];
console.log(clients.indexOf("Poly")); // 2
console.log(clients.indexOf("Monkong")); // -1
</code>
        </pre>
        <p>
          У цьому прикладі масив clients містить імена клієнтів. Виклик
          <code>indexOf("Poly")</code> повертає індекс першого входження рядка
          <code>“Poly"</code> у масиві, який дорівнює <code>2</code>, усі
          наступні входження (індекс <code>4</code>) уже не будуть
          аналізуватися. Виклик <code>indexOf("Monkong")</code> повертає
          <code>-1</code>, оскільки елемент <code>**"**Monkong**"**</code> не
          знайдений у масиві.
        </p>
        <p>
          Функція <code>getSlice(array, value)</code> приймає два параметра:
        </p>

        <p><code>array</code> - масив довільних елементів</p>
        <p><code>value</code> - значення елемента масиву для пошуку</p>
        <p>
          Доповни код функції <code>getSlice(array, value)</code> так, щоб вона
          виконувала пошук значення value у масиві <code>array</code> і
          повертала:
        </p>

        <p>
          порожній масив, якщо в <code>array</code> немає елемента зі значенням
          value
        </p>
        <p>
          підмасив, що починається з початку array і до елемента зі значенням
          <code>value</code> включно, якщо такий елемент є в array
        </p>
        <p>Оголошена функція <code>getSlice(array, value)</code></p>
        <p>
          Виклик
          <code>getSlice(["Mango", "Poly", "Ajax"], "Poly")</code> повертає
          <code>["Mango", "Poly"]</code>
        </p>
        <p>
          Виклик
          <code>getSlice(["Mango", "Poly", "Ajax"], "Ajax")</code> повертає
          <code>["Mango","Poly", "Ajax"]</code>
        </p>
        <p>
          Виклик
          <code>getSlice(["Mango", "Poly", "Ajax"], "Mango")</code> повертає
          <code>["Mango"]</code>
        </p>
        <p>
          Виклик
          <code>getSlice(["Mango", "Poly", "Ajax"], "Jacob")</code> повертає
          <code>[]</code>
        </p>
        <p>
          Виклик
          <code>getSlice(["Mango", "Poly", "Ajax"], "Casey")</code> повертає
          <code>[]</code>
        </p>
        <pre>
<code>
function getSlice(array, value) {
  const index = array.indexOf(value);
  
  if (index === -1) {
    return [];
  }
  
  return array.slice(0, index + 1);
}
</code>
        </pre>

        <p>Пояснення:</p>
        <p>
          indexOf(value): Метод indexOf шукає значення value у масиві array.
          Якщо значення знайдено, метод повертає його індекс (позицію). Якщо
          значення немає в масиві, indexOf повертає -1.
        </p>
        <p>
          Умовний оператор: Якщо індекс дорівнює -1, це означає, що значення
          value немає в масиві, і функція повертає порожній масив.
        </p>
        <p>
          slice(0, index + 1): Якщо значення знайдено, повертається підмасив від
          початку масиву array до індексу value включно (тому ми додаємо 1 до
          index).
        </p>
        <p>Приклади роботи:</p>
        <p>
          getSlice(["Mango", "Poly", "Ajax"], "Poly") повертає ["Mango",
          "Poly"].
        </p>
        <p>
          getSlice(["Mango", "Poly", "Ajax"], "Ajax") повертає ["Mango", "Poly",
          "Ajax"].
        </p>
        <p>getSlice(["Mango", "Poly", "Ajax"], "Mango") повертає ["Mango"].</p>
        <p>getSlice(["Mango", "Poly", "Ajax"], "Jacob") повертає [].</p>
        <h4>Метод push()</h4>
        <p>
          Метод масиву <code>push()</code> використовується для додавання одного
          або більше елементів у кінець масиву.
        </p>
        <p>Синтаксис методу <code>push()</code> має такий вигляд:</p>
        <pre>
<code>
array.push(element1, element2, ..., elementN);
</code>
        </pre>
        <p>
          <code>array</code> — це вихідний масив, до якого потрібно додати
          елементи;
        </p>
        <p>
          <code>element1, element2, ..., elementN</code> — елементи, які
          необхідно додати в кінець масиву.
        </p>
        <pre>
<code>
const planets = ["Earth", "Mars", "Venus"];

planets.push("Jupiter");
console.log(planets); // ['Earth', 'Mars', 'Venus', 'Jupiter']

planets.push("Saturn", "Neptune");
console.log(planets); // ['Earth', 'Mars', 'Venus', 'Jupiter', "Saturn", "Neptune"]
</code>
        </pre>
        <p>
          За допомогою циклу ми можемо виконувати повторювані операції і
          використовувати метод push для додавання нових елементів у масив на
          кожній ітерації.
        </p>
        <pre>
<code>
const tags = [];

for(let i = 0; i &lt; 3; i += 1) {
	tags.push(`tag-${i}`);
}

console.log(tags); // ["tag-0", "tag-1", "tag-2"]
</code>
        </pre>
        <!-- Задача -->
        <p>Функція createArrayOfNumbers(min, max) приймає два параметра:</p>

        <p><code>min</code> - ціле число, з якого починаються обчислення</p>
        <p>
          <code>max</code> - ціле число, до якого включно триватимуть обчислення
        </p>
        <p>
          Доповни код функції <code>createArrayOfNumbers(min, max)</code> таким
          чином, щоб вона повертала масив усіх цілих чисел від значення min до
          max включно.
        </p>
        <p>Оголошена функція createArrayOfNumbers(min, max)</p>
        <p>Виклик функції createArrayOfNumbers(1, 3) повертає [1, 2, 3]</p>
        <p>
          Виклик функції createArrayOfNumbers(14, 17) повертає [14, 15, 16, 17]
        </p>
        <p>
          Виклик функції createArrayOfNumbers(29, 34) повертає [29, 30, 31, 32,
          33, 34]
        </p>
        <p>
          Виклик функції createArrayOfNumbers() з випадковими min і max повертає
          правильний масив
        </p>
        <p>В циклі for використовувався метод push</p>
        <pre>
<code>
function createArrayOfNumbers(min, max) {
  const numbers = [];
  
  for (let i = min; i &lt;= max; i += 1) {
    numbers.push(i);
  }
  
  return numbers;
}

console.log(createArrayOfNumbers(1, 3));  // [1, 2, 3]
console.log(createArrayOfNumbers(14, 17)); // [14, 15, 16, 17]
console.log(createArrayOfNumbers(29, 34)); // [29, 30, 31, 32, 33, 34]
</code>
        </pre>
        <p>Як працює ця функція:</p>
        <p>Оголошення масиву numbers:</p>
        <p>
          Спочатку створюється порожній масив numbers, який буде заповнюватися
          цілими числами від min до max.
        </p>
        <p>Цикл for:</p>
        <p>
          Цикл починається з min і триває до max, включаючи обидва значення.
        </p>
        <p>
          З кожною ітерацією значення i додається до масиву numbers за допомогою
          методу push().
        </p>
        <p>Повернення результату:</p>
        <p>
          Після завершення циклу функція повертає заповнений масив numbers, що
          містить всі числа від min до max.
        </p>
      </div>
    </section>
    <script src="js/jsgo.js"></script>
    <script src="js/connect.js" defer></script>
    <script src="js/typeof.js" defer></script>
    <script src="js/sasha.js" defer></script>
    <script src="js/if.js" defer></script>
    <script src="js/good.js" defer></script>
  </body>
</html>
