<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="css/jsgo.css" />

    <title>JavaScript</title>
  </head>
  <body>
    <section>
      <nav class="nav">
        <h1>JavaScript 3.0</h1>
        <ol>
          <li>
            <a href="#module-one"
              >Модуль 1. Змінні та типи. Основи функцій. Module 1: Variables and
              types. The basics of functions.</a
            >
          </li>
          <li><a href="#"></a></li>
          <li><a href="#"></a></li>
          <li><a href="#"></a></li>
          <li><a href="#"></a></li>
        </ol>
      </nav>
    </section>

    <section>
      <div class="container">
        <!-- Словник -->
        <h2>Словник.</h2>
        <p>
          <dfn>Інструкція (statements)</dfn> — це повний блок коду, який виконує
          певну дію або набір дій. Інструкція може складатися з одного або
          кількох виразів і зазвичай закінчується крапкою з комою ;. Інструкції
          часто використовуються для управління потоком виконання коду.
        </p>
        <p>
          Види інструкцій. Оголошення змінних: let x = 10; Умовні оператори: if
          (condition) {...}; Цикли: for, while; Виклик функції: myFunction();
        </p>
        <p>
          <dfn>Вираз (Expression) </dfn>— це будь-який фрагмент коду, який може
          бути обчислений та повертає значення. Вирази можуть включати числа,
          рядки, змінні, функції, та операції між ними. Вирази можуть бути
          частиною інструкції.
        </p>
        <p>
          Види виразів: числові вирази: 3 + 7, логічні вирази: x > 10, рядкові
          вирази: "Hello" + " World".
        </p>

        <p>
          <dfn>Оператор</dfn> — це спеціальний символ або ключове слово, яке
          виконує певну дію над одним або кількома значеннями або змінними.
          Оператори дозволяють виконувати арифметичні обчислення, логічні
          порівняння, присвоєння значень змінним і багато іншого.
        </p>

        <p>Приклади операторів:</p>
        <p>
          Арифметичні оператори: +, -, *, / (додавання, віднімання, множення,
          ділення).
        </p>
        <p>Логічні оператори: &&, ||, ! (логічне "і", "або", "не").</p>
        <p>
          Оператори порівняння: ==, ===, !=, > (рівність, строга рівність,
          нерівність, більше).
        </p>
        <p>Оператор присвоєння: = (присвоєння значення змінній).</p>

        <!-- Констект -->
        <h3>
          Інструкції для роботи с консолью в браузері. Instructions for working
          with the console in a browser.
        </h3>
        <p>Прописати в браузері <mark>about:blank</mark></p>
        <p>
          Прописати <mark>allow pasting</mark> (якщо треба) щоб дозволити
          вставлення коду.
        </p>
        <p>
          <mark>console.clear()</mark> - це треба прописати в консолі, щоб
          видалити з нього код.
        </p>

        <p id="lit"></p>
        <p id="global"></p>
        <p id="defined"></p>

        <h2 id="module-one">
          Модуль 1. Змінні та типи. Основи функцій. Module 1: Variables and
          types. The basics of functions.
        </h2>

        <h3>Базова термінологія JavaScript. Basic JavaScript terminology.</h3>

        <p>
          <dfn>Код</dfn> — це набір інструкцій, які комп'ютер може зрозуміти й
          виконати.
        </p>
        <p>
          <dfn>Компілятор, інтерпретатор</dfn> - спеціальна програма, яка
          конвертує вихідний код у набір інструкцій, зрозумілих комп'ютеру.
        </p>
        <p>
          <dfn>Вихідний код (source code)</dfn> — це текст комп'ютерної
          програми, набір синтаксичних конструкцій, що описують набір інструкцій
          для комп'ютера.
        </p>
        <p><dfn>Алгоритм</dfn> — це набір кроків, задля досягнення мети.</p>
        <p><dfn>Алгоритм</dfn> створення програми</p>
        <ul>
          <li>розбити завдання на більш дрібні підзавдання;</li>
          <li>визначити послідовність виконання підзавдань;</li>
          <li>
            використовувати відповідні інструменти для розв’язання завдання.
          </li>
        </ul>

        <p>
          Необхідно добре знати синтаксис мови, тренуватися мислити алгоритмічно
        </p>

        <p>
          <dfn>Інструкція (statement)</dfn> — це пов'язаний набір слів і
          символів із синтаксису мови, які об'єднуються, щоб висловити одну
          ідею.
        </p>

        <code><pre>a = b * 2;</pre></code>
        <p>
          інструкції закінчуються <mark><code>;</code></mark>
        </p>
        <p>
          <mark><code>a</code></mark> і <mark><code>b</code></mark> — змінні —
          це сховища даних, які складаються з ідентифікатора (імені) та
          пов'язаного з ним значення.
        </p>

        <mark><code>2</code></mark> — просто число - називається значенням
        літералу (literal value).

        <p>
          <mark><code>= *</code></mark
          >— оператори, що виконують дії над значеннями та змінними.
        </p>

        <h3>Вираз та літерал. Expression and literal.</h3>

        <p>
          <dfn>Вираз (expression)</dfn> — це посилання на змінну чи значення,
          або на набір змінних і значень у поєднанні з операторами.
        </p>

        <p>
          <mark><code>b * 2</code></mark> — арифметичний вираз множення.
        </p>
        <p>
          <mark><code>a = b * 2</code></mark> — вираз присвоювання.
        </p>

        <p>
          Існують інші типи виразів: вирази виклику функцій, вирази порівняння
          тощо.
        </p>
        <code>
          <pre>
// Числовий літерал
10

// Рядковий літерал
"JavaScript is awesome!"
            </pre
          >
        </code>

        <h3>Підключення скрипта. Connect the script.</h3>
        <p>
          Для підключення скрипта JavaScript до HTML-сторінки можна використати
          тег <code>&lt;script&gt;</code>. Існує кілька способів, як це можна
          зробити:
        </p>

        <!-- Твій JavaScript-код тут -->
        <h5>Вбудований код з виводом інформаціє на веб сторінку</h5>

        <p id="definedd"></p>
        <script>
          const hi = 'Hello, world';
          console.log(hi);
          document.getElementById('definedd').innerText = hi;
        </script>

        <p>
          <dfn>Суворий режим (англ. strict mode)</dfn> — режим повної
          відповідності сучасному стандарту, що запобігає певним помилкам,
          наприклад, використанню небезпечних і застарілих конструкцій.
        </p>
        <p>
          Щоб увімкнути суворий режим, потрібно додати директиву 'use strict';
          на початок скрипта.
        </p>

        <p>
          Комбінації клавіш відкривають інструменти розробника на вкладці
          Console: <mark>Ctrl + Shift + J;</mark>
        </p>

        <h4>Метод <code>console.log()</code></h4>
        <code>
          <pre>
              console.log("JavaScript is awesome!");
              console.log(10);
            </pre
          >
        </code>
        <script>
          console.log('JavaScript is awesome!');
          console.log(10);
        </script>

        <h3>Перевизначення значення. Overriding a value.</h3>
        <code>
          <pre>
              let username = "Mango";
              username = "Poly";
            </pre
          >
        </code>

        <p>
          Для оголошення змінної, якій згодом можна задати нове значення,
          використовується ключове слово <mark>let</mark>.
        </p>
        <p id="usernamePoly"></p>

        <p>
          Змінним, оголошеним через let, необов'язково відразу задавати
          значення. У разі оголошення змінної без значення, змінна
          ініціалізується зі спеціальним значенням
          <dfn>undefined (англ. не визначено)</dfn>.
        </p>

        <p id="userNameUndefined"></p>

        <p>
          Якщо звернутися до змінної до її оголошення з'явится помилка:
          "ReferenceError: age is not defined"
        </p>

        <p id="userAge"></p>

        <h3>Типи даних. Data types.</h3>

        <p>
          <dfn>Числа (Number)</dfn> - можуть бути позитивними, негативними,
          цілими або дробовими. Ціла та дробова частини числа розділяються
          крапкою.
        </p>

        <p>
          <dfn>Рядок (String)</dfn> - є послідовністю символів, вкладених в
          одинарні '' або подвійні лапки "".
        </p>

        <p>
          <dfn>Логічний тип даних (Boolean)</dfn> має лише два значення: true і
          false (пишеться без лапок на відміну від рядка).
        </p>

        <p>
          Імена змінних, що містять логічні значення, звучать як питання, на яке
          можна відповісти “так” чи “ні”.
        </p>

        <p>
          <dfn>Undefined:</dfn> Тип даних, який має одне значення — undefined.
          Це означає, що змінна була оголошена, але їй не було присвоєно
          значення.
        </p>

        <code>
          <pre>
let x;
console.log(x); // undefined</pre
          >
        </code>

        <p>
          <dfn>Null:</dfn> Це спеціальне значення, яке означає "немає значення".
          Тип null також є примітивним типом.
        </p>

        <code>
          <pre>
let y = null;
console.log(y); // null</pre
          >
        </code>

        <p>
          <dfn>Object:</dfn> Складний тип даних, який використовується для
          зберігання колекцій даних і складних сутностей. Прикладом об'єкта є
          об'єкт {} або масив []
        </p>

        <code>
          <pre>
let obj = { name: "Alice", age: 30 };
let arr = [1, 2, 3];</pre
          >
        </code>
        <p>
          <dfn>BigInt:</dfn> Цей тип даних дозволяє працювати з цілими числами,
          які виходять за межі діапазону типу Number.
        </p>
        <code>
          <pre>
let bigInt = 1234567890123456789012345678901234567890n;
console.log(bigInt); // 1234567890123456789012345678901234567890n</pre
          >
        </code>
        <p>
          <dfn>Symbol:</dfn> Це унікальний і незмінний примітивний тип даних,
          який використовується для створення унікальних ідентифікаторів для
          об'єктів.
        </p>

        <code>
          <pre>
let sym = Symbol("description");
console.log(sym); // Symbol(description)</pre
          >
        </code>

        <h3>Спеціальні значення. Special values.</h3>

        <p>
          <code><dfn>null</dfn></code> вказує на відсутність значення, часто
          використовується для позначення порожнього значення (має бути явно
          присвоєно змінній).
        </p>

        <code><dfn>undefined</dfn></code> автоматично присвоюється змінній,
        якщо:
        <ul>
          <li>змінній було явно задано значення undefined;</li>
          <li>
            змінна була оголошена, але ще не була ініціалізована значенням.
          </li>
        </ul>

        <p>
          Значення undefined каже нам, що значення на даний момент невідоме чи
          невизначене.
        </p>

        <h3>Оператор typeof. Operator typeof.</h3>

        <p>
          <code><dfn>typeof</dfn></code>
          використовується для визначення типу даних значення або виразу.
        </p>

        <p>
          <code><dfn>typeof</dfn></code> для перевірки типу значення null, він
          повертає рядок object.
        </p>

        <p>
          В ранніх версіях JavaScript null було розглянуто як спеціальний
          випадок об’єкта - це була помилка в реалізації мови, збережена для
          забезпечення зворотної сумісності з існуючим кодом.
        </p>

        <h3>Арифметичні операції</h3>

        <p>
          Правила порядку виконання операцій аналогічні математичним: спершу дії
          в дужках, потім степені й корені, потім множення та ділення тощо.
        </p>

        <ul>
          <li>
            Оператор (+) використовується для складання двох чисел.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x + y); // 13</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (-) використовується для віднімання одного числа від
            іншого.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x - y); // 3</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (*) використовується для множення двох чисел.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x * y); // 40</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (/) використовується для ділення одного числа на інше.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x / y); // 1.6</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (%) повертає остачу від ділення одного числа на інше.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x % y); // 3</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (**) використовується для піднесення числа до степеня.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x ** y); // 32768</pre
                >
              </code>
            </p>
          </li>
        </ul>

        <p>
          Доповни код, присвоївши змінній totalPrice вираз для підрахунку
          загальної суми замовлення. Змінна pricePerItem зберігає ціну за
          одиницю товару, а orderedQuantity - кількість одиниць товару в
          замовленні.
        </p>

        <p>
          <code>
            <pre>
const pricePerItem = 3500;
const orderedQuantity = 4;

// Change code below this line
const totalPrice = pricePerItem * orderedQuantity;</pre
            >
          </code>
        </p>

        <p>
          <dfn>Комбіновані оператори</dfn> дозволяють більш компактно виконувати
          арифметичні операції та одночасно оновлювати значення змінної,
          виходячи з її попереднього значення.
        </p>

        <ul>
          <li>
            <dfn>Додавання:</dfn> <code>+=</code>. Приклад:
            <code>x += y</code> еквівалентно <code>x = x + y</code>
          </li>
          <li>
            <dfn>Віднімання:</dfn> <code>-=</code>. Приклад:
            <code>x -= y</code> еквівалентно <code>x = x - y</code>
          </li>
          <li>
            <dfn>Множення:</dfn> <code>*=</code>. Приклад:
            <code>x *= y</code> еквівалентно <code>x = x * y</code>
          </li>
          <li>
            <dfn>Ділення:</dfn> <code>/=</code>. Приклад:
            <code>x /= y</code> еквівалентно <code>x = x / y</code>
          </li>
          <li>
            <dfn>Остача від ділення:</dfn> <code>%=</code>. Приклад:
            <code>x %= y</code> еквівалентно <code> x = x % y</code>
          </li>
        </ul>

        <p id="age"></p>

        <h3>
          Конкатенація (склеювання) рядків. Concatenation (gluing) of strings.
        </h3>
        <p>
          Якщо застосувати оператор + до рядка та будь-якого іншого типу даних,
          результатом буде новий рядок, що містить об'єднання вихідних значень.
          Це називається <dfn>конкатенація (склеювання)</dfn>. Під час
          конкатенації будь-який тип даних буде приведено до рядка та поєднано з
          іншим рядком.
        </p>

        <p>
          <code>
            <pre>
const message = "Mango " + "is" + " happy";
console.log(message); // "Mango is happy"</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
const age = 24;
const message = "Poly is " + age + " years old!";</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
console.log("Mango" + 55); // "Mango55"
console.log("Mango" + true); // "Mangotrue"</pre
            >
          </code>
        </p>

        <p>
          Проте порядок операндів має значення. Перетворення типів відбувається
          лише в момент операції додавання з рядком. До цього моменту
          застосовуються нормальні правила математики.
        </p>

        <p>
          <code>
            <pre>
console.log(1 + "2"); // "12"
console.log(1 + "2" + 4); // "124"
console.log(1 + 2 + "4"); // "34"</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
const username = "Poly";
const message = "Welcome " + username + "!";
console.log(message);</pre
            >
          </code>
        </p>

        <h3>Перетворення типів: рядки. Converting types: strings.</h3>
        <p>
          Перетворення типів у JavaScript — це процес зміни значення одного типу
          даних на інший тип даних. У JavaScript існують два типи перетворення:
          явне та неявне.
        </p>

        <h4>Явне перетворення типів</h4>
        <p>
          Для перетворення будь-якого значення на рядок можна використовувати
          вбудовану функцію <code>String()</code>
        </p>

        <p>
          <code>
            <pre>
console.log(String(5)); // "5"
console.log(String(true)); // "true"
console.log(String(false)); // "false"
console.log(String(null)); // "null"
console.log(String(undefined)); // "undefined"</pre
            >
          </code>
        </p>
        <p>
          Наприклад, якщо виконується операція додавання (<code>+</code>) між
          рядком та іншим типом даних, JavaScript автоматично перетворює
          значення операнда на рядок і виконує конкатенацію рядків.
        </p>

        <h4>Неявне перетворення типів</h4>

        <p>
          <code>
            <pre>
console.log("5" + 3); // "53"
console.log("5" + true); // "5true"
console.log("5" + false); // "5false"
console.log("5" + null); // "5null"
console.log("5" + undefined); // "5undefined"</pre
            >
          </code>
        </p>

        <p>
          <dfn>Шаблонні рядки</dfn> — це синтаксис, який полегшує об'єднання
          статичного тексту з динамічним (тобто текстом, що містить змінні,
          обчислення тощо).
        </p>

        <p>
          Код не працюватиме, якщо огорнути шаблонні рядки звичайними одинарними
          або подвійними лапками.
        </p>

        <p>
          Шаблонні рядки дозволяють підставляти значення змінних безпосередньо
          всередині рядка за допомогою синтаксису інтерполяції
          <code>${змінна}</code>.
        </p>

        <p>
          <code>
            <pre>
const guestName = "Mango";
const roomNumber = 207;
const greeting = `Welcome ${guestName}, your room number is ${roomNumber}!`;
console.log(greeting); // "Welcome Mango, your room number is 207!"</pre
            >
          </code>
        </p>

        <h4>Порівняння конкатенації та шаблонних рядків</h4>

        <p>Код з конкатенацією.</p>
        <p>
          <code>
            <pre>
const guestName = "Mango";
const roomNumber = 207;
const greeting =
  "Welcome " + guestName + ", your room number is " + roomNumber + "!";
console.log(greeting); // "Welcome Mango, your room number is 207!"</pre
            >
          </code>
        </p>

        <p>Код, де значення змінних підставляються у шаблонний рядок.</p>
        <p>
          <code>
            <pre>
const guestName = "Mango";
const roomNumber = 207;
const greeting = `Welcome ${guestName}, your room number is ${roomNumber}!`;
console.log(greeting); // "Welcome Mango, your room number is 207!"</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
const productName = "Droid";
const pricePerItem = 3500;

// Change code below this line
const message = `You picked ${productName}, price per item is ${pricePerItem} credits`;</pre
            >
          </code>
        </p>

        <h4>Замовлення продукту</h4>

        <p>
          <code>
            <pre>
const pricePerDroid = 800;
const orderedQuantity = 6;
const deliveryFee = 50;
const totalPrice = pricePerDroid * orderedQuantity + deliveryFee;
const message = `You ordered droids worth ${totalPrice} credits`;
console.log(message);</pre
            >
          </code>
        </p>

        <h3>Довжина рядка. Length of the string.</h3>
        <p><dfn>Властивості</dfn> — це описові характеристики сутності.</p>
        <p>
          Для доступу до властивості (<mark>property</mark>) сутності
          (<mark>objectName</mark>) використовується синтаксис із крапкою:
        </p>

        <p><code>сутність.властивість</code></p>

        <p>
          Наприклад, щоб отримати довжину рядка, ми можемо використовувати
          властивість <code>length</code> таким чином:
        </p>

        <p>
          <code>
            <pre>
const productName = "Repair droid";

// Якщо у змінній зберігається рядок
console.log(productName.length); // 12

// Якщо рядковий літерал
console.log("Repair droid".length); // 12</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
const username = "Poly";
const message = `Username ${username} is ${username.length} characters long`;
console.log(message);

Username Poly is 4 characters long
</pre
            >
          </code>
        </p>

        <h4>Індексація рядків. String indexing.</h4>
        <p>
          <dfn>Рядки</dfn> — це набори символів, де кожен символ має свій
          порядковий номер (індекс). Індексація елементів рядка починається з
          нуля.
        </p>

        <p>
          Для доступу до певного символу рядка ми використовуємо синтаксис
          квадратних дужок, де вказуємо індекс потрібного символу:
          <code>string[index]</code>.
        </p>

        <p>
          <code>
            <pre>
const product = "Repair droid";
console.log(product[0]); // 'R'
console.log(product[5]); // 'r'
console.log(product[11]); // 'd'
</pre
            >
          </code>
        </p>

        <p>
          Отримання останнього символу рядка можливе за його індексом
          <code>string[lastIndex]</code>. Щоб знайти індекс останнього символу
          рядка, треба від довжини цього рядка відняти одиницю
          <code>string.length - 1</code>
        </p>

        <p>
          <code>
            <pre>
const product = "Repair droid";
const lastElementIndex = product.length - 1;
console.log(product[lastElementIndex]); // 'd'
</pre
            >
          </code>
        </p>

        <p>
          Для доступу до останнього символу рядка без створення проміжної
          змінної ми можемо вставити вираз (<code>product.length - 1</code>) у
          квадратні дужки при зверненні до елемента.
        </p>

        <p>
          <code>
            <pre>
const product = "Repair droid";
console.log(product[product.length - 1]); // 'd'
</pre
            >
          </code>
        </p>

        <p>Додай код, який записує у змінні наступні значення:</p>

        <p><code>courseTopicLength</code> - довжина рядка</p>
        <p><code>firstElement</code> - перший символ рядка</p>
        <p>
          <code>lastElement</code> - останній символ рядка (використовуй змінну
          courseTopicLength)
        </p>

        <p>
          <code>
            <pre>
const courseTopic = "JavaScript essentials";

const courseTopicLength = courseTopic.length;
const firstElement = courseTopic[0];
const lastElement = courseTopic[courseTopicLength - 1]; 

</pre
            >
          </code>
        </p>

        <h3>Незмінність рядків. String immutability.</h3>

        <p>
          Коли рядок створюється, він стає незмінним (не можна замінити окремі
          символи всередині рядка).
        </p>

        <p>
          <code>
            <pre>
let product = "Droid";
console.log(product); // "Droid"

// Це не має жодного ефекту
product[2] = "O";
console.log(product); // "Droid" 
</pre
            >
          </code>
        </p>

        <p>
          Натомість ми повинні створити новий рядок і присвоїти його змінній
          новий рядок замість старого .
        </p>

        <p>
          <code>
            <pre>
let product = "Droid";
console.log(product); // "Droid"

product = "DrOid";
console.log(product); // "DrOid"
</pre
            >
          </code>
        </p>

        <!-- Section: Comparison operators.-->

        <h3>Оператори порівняння. Comparison operators.</h3>

        <p>
          Оператори порівняння повертають булеве значення (<code>true</code> або
          <code>false</code>) залежно від результату порівняння.
        </p>

        <p>Оператор &gt; (більше);</p>
        <p>Оператор &lt; (менше);</p>
        <p>Оператор &gt;= (більше або дорівнює);</p>
        <p>Оператор &lt;= (менше або дорівнює)</p>

        <p>
          <code>
            <pre>
const a = 2;
const b = 5;

console.log(a &gt; b); // false
console.log(b &gt; a); // true
console.log(a &gt;= b); // false
console.log(b &gt;= a); // true

console.log(a &lt; b); // true
console.log(b &lt; a); // false
console.log(a &lt;= b); // true
console.log(b &lt;= a); // false
</pre
            >
          </code>
        </p>

        <p>
          Оголоси змінну <code>isAdult</code> та задай їй результат перевірки
          значення змінної <code>age</code>. Використай оператори порівняння та
          доповни код так, щоб значенням <code>isAdult</code> було
          <code>true</code>, якщо вік користувача більше або дорівнює 18 та
          <code>false</code>, якщо менше 18.
        </p>

        <p>
          <code>
            <pre>
const age = 16; 
const isAdult = age >= 18;

console.log(isAdult);
</pre
            >
          </code>
        </p>

        <h3>Оператори рівності</h3>

        <p>Оператор == (дорівнює);</p>
        <p>Оператор != (не дорівнює);</p>

        <p>
          <code>
            <pre>
console.log(5 == 5); // true
console.log(5 == 3); // false
console.log(5 != 3); // true
console.log(5 != 5); // false
</pre
            >
          </code>
        </p>

        <p>Оператор === (сувора рівність);</p>
        <p>Оператор !== (сувора нерівність)</p>

        <p>
          <code>
            <pre>
console.log(5 === 5); // true
console.log(5 === "5"); // false
console.log(5 !== "5"); // true
console.log(5 !== 5); // false
console.log(1 === true); // false
console.log(1 !== true); // true
</pre
            >
          </code>
        </p>

        <p>
          Оголоси змінну <code>isValid</code> і задай їй значенням результат
          перевірки рівності паролей в змінних <code>correctPassword</code> і
          <code>userPassword</code>. Якщо паролі співпадають (сувора рівність),
          значення <code>isValid</code> має бути true Якщо паролі не
          співпадають, значення <code>isValid</code> має бути <code>false</code>
        </p>

        <p>
          <code>
            <pre>
const correctPassword = "jqueryismyjam";
const userPassword = "mangodab3st";
const isValid = correctPassword === userPassword;
</pre
            >
          </code>
        </p>

        <h4>Перетворення типів: числа</h4>
        <p>
          Для явного перетворення будь-якого значення в число можна
          використовувати вбудовану функцію <code>Number()</code>, яка повертає
          результат у вигляді числа.
        </p>

        <p>
          <code>
            <pre>
console.log(Number("5")); // 5
console.log(Number(true)); // 1
console.log(Number(false)); // 0
console.log(Number(null)); // 0
</pre
            >
          </code>
        </p>

        <p>true завжди приводиться до 1;</p>
        <p>false , null і "" завжди приводяться до 0.</p>

        <p>
          Якщо неможливо привести значення до числа, результатом перетворення
          буде спеціальне значення <code>NaN</code> (Not a Number).
        </p>

        <p>
          <code>
            <pre>
console.log(Number(undefined)); // NaN
console.log(Number("Jacob")); // NaN
console.log(Number("25px")); // NaN
</pre
            >
          </code>
        </p>

        <p>
          Арифметичні операції (<code>+, -, *, /</code>) виконують неявне
          перетворення типів.
        </p>

        <p>
          <code>
            <pre>
console.log("5" * 2); // 10
console.log("10" - 5); // 5
console.log(5 + true); // 6
console.log(5 - true); // 4
</pre
            >
          </code>
        </p>

        <p>
          Якщо у виразі присутній хоча б один із операндів з типом числа, то
          обидва операнди приводяться до чисел. Це відбувається у всіх
          арифметичних операціях, окрім додавання. + біля рядкових операндів
          викликає їх з'єднання (конкатинацію).
        </p>

        <p>
          У разі використання операторів порівняння (&lt;, &gt;, &lt;=, &gt;=)
          також виконується неявне перетворення типів. Якщо операнди різних
          типів, то перед порівнянням вони приводяться до числа.
        </p>

        <p>
          <code>
            <pre>
console.log("10" &gt; 5); // true
console.log(10 &gt; "5"); // true
console.log(5 &gt; true); // true
console.log(5 &lt; true); // false
console.log("5" &lt; true); // false
</pre
            >
          </code>
        </p>

        <h3>Перетворення рядків у числа.</h3>

        <p>Метод <code>Number.parseInt()</code> приймає 2 аргументи:</p>

        <ul>
          <li>
            Рядок. Якщо аргумент не є рядком, то він буде спочатку перетворений
            у рядок
          </li>
          <li>
            Система числення, до якої відноситься рядок (не обов’язковий
            аргумент, за замовчуванням десяткова система). Наприклад, для
            десяткової системи буде 10, для шістнадцяткової - 16 тощо.
          </li>
        </ul>

        <p>
          Метод аналізує рядок зліва направо, видаляючи пробіли на початку і
          перетворюючи допустимі символи у число до тих пір, поки не зіткнеться
          з першим недопустимим символом. Після цього аналіз припиняється, і вже
          перетворене ціле число повертається.
        </p>

        <p>
          <code>
            <pre>
console.log(Number.parseInt("5")); // 5
console.log(Number.parseInt("5.5")); // 5
console.log(Number.parseInt("5cm")); // 5
console.log(Number.parseInt("12qwe74")); // 12
console.log(Number.parseInt("12.46qwe79")); // 12
console.log(Number.parseInt("cm5")); // NaN
console.log(Number.parseInt("")); // NaN
console.log(Number.parseInt("qweqwe")); // NaN
</pre
            >
          </code>
        </p>

        <p>
          Якщо перші символи рядка не можуть бути перетворені на число, або
          рядок порожній чи відсутній, результатом буде значення NaN (Not a
          Number).
        </p>

        <h4>Метод <code>Number.parseFloat()</code></h4>

        <p>
          Метод <code>Number.parseFloat()</code> аналогічний
          <code>Number.parseInt()</code> з однієї відмінністю: перетворює рядок
          на число з плаваючою крапкою.
        </p>

        <p>
          <code>
            <pre>
console.log(Number.parseFloat("5")); // 5
console.log(Number.parseFloat("5.5")); // 5.5
console.log(Number.parseFloat("3.14")); // 3.14
console.log(Number.parseFloat("5cm")); // 5
console.log(Number.parseFloat("5.5cm")); // 5.5
console.log(Number.parseFloat("12qwe74")); // 12
console.log(Number.parseFloat("12.46qwe79")); // 12.46
console.log(Number.parseFloat("cm5")); // NaN
console.log(Number.parseFloat("")); // NaN
console.log(Number.parseFloat("qweqwe")); // NaN
</pre
            >
          </code>
        </p>

        Порожній чи відсутній, результатом буде значення
        <code>NaN (Not a Number)</code>.

        <!--  -->
        <h4>Арифметичні функції. Arithmetic functions.</h4>

        <p>
          Клас Math надає методи для виконання математичних операцій та роботи з
          числами.
        </p>
        <p>Клас Math є вбудованим класом JavaScript.</p>
        <p>Кілька методів, які надає клас Math:</p>

        <ul>
          <li>
            <mark>Math.floor(num):</mark> повертає найближче ціле число, яке є
            меншим або дорівнює вказаному числу <mark>num</mark>.

            <code>
              <pre>
    console.log(Math.floor(1.3)); // 1
    console.log(Math.floor(1.7)); // 1
            </pre
              >
            </code>
          </li>

          <li>
            <mark>Math.ceil(num):</mark> повертає найближче ціле число, яке є
            більшим, або дорівнює зазначеному числу <mark>num</mark>.
            <p>
              <code>
                <pre>
    console.log(Math.ceil(1.3)); // 2
    console.log(Math.ceil(1.7)); // 2
                  </pre
                >
              </code>
            </p>
          </li>

          <li>
            <mark>Math.round(num):</mark> повертає значення числа після
            округлення за математичними правилами - якщо десяткова частина числа
            менша 0.5, то округлення буде в меншу сторону, якщо 0.5 і більше —
            то в більшу.<mark>num</mark>.
            <p>
              <code>
                <pre>
    console.log(Math.round(1.3)); // 1
    console.log(Math.round(1.7)); // 2
                  </pre
                >
              </code>
            </p>
          </li>

          <li>
            <mark>Math.max(num1, num2, ...):</mark> повертає найбільше число з
            набору переданих чисел.
            <p>
              <code>
                <pre>
    console.log(Math.max(20, 10, 50, 40)); // 50
                </pre>
              </code>
            </p>
          </li>

          <li>
            <mark>Math.min(num1, num2, ...):</mark> повертає найменше число з
            набору переданих чисел.
            <p>
              <code>
                <pre>
    console.log(Math.min(20, 10, 50, 40)); // 10
                </pre>
              </code>
            </p>
          </li>

          <li>
            <mark>Math.random():</mark> повертає випадкове число в діапазоні від
            0 (включно) до 1 (за винятком).
            <p>
              <code>
                <pre>
    console.log(Math.random()); // випадкове число між 0 і 1, наприклад 0.2 ... 0.9166353649342294
                </pre>
              </code>
            </p>
          </li>

          <p>
            Math, також надає методи для тригонометричних функцій, логарифмів та
            інших математичних операцій.
          </p>
        </ul>

        <h4>Дробове число. Fractional number.</h4>
        <p>0.1 + 0.2 не дорівнює 0.3.</p>
        <p>
          Число 0.1 у двійковій системі числення, яку використовує комп'ютер —
          це нескінченний дріб.
        </p>
        <p>
          Двійкове значення нескінченних дробів зберігається лише до певного
          знака.
        </p>
        <p>
          <code>
            <pre>
    console.log(0.1 + 0.2 === 0.3); // false
    console.log(0.1 + 0.2); // 0.30000000000000004
                  </pre
            >
          </code>
        </p>
        <p>
          Щоб при додаванні двох дробових чисел, наприклад 0.1 + 0.2 виходило
          0.3, можна використати два підходи.
        </p>
        <ul>
          <li>
            1. Помножити числа на досить велике число (наприклад, 10 або 100),
            виконати додавання, зозділити результат на те саме число, щоб
            повернути його до початкового масштабу.
            <code>
              <pre>
    console.log(0.1 * 10 + 0.2 * 10); // 3
    console.log((0.1 * 10 + 0.2 * 10) / 10); // 0.3
                  </pre
              >
            </code>
          </li>
          <li>
            2. Метод <code><mark>toFixed()</mark></code> для округлення
            результату до певної кількості знаків після крапки.
            <code>
              <pre>
    console.log((0.1 + 0.2).toFixed(1)); // "0.3"
    console.log((5).toFixed(2));  //  ”5.00”
    console.log((8.762195).toFixed(4));  //  “8.7622”
                  </pre
              >
            </code>
          </li>
        </ul>

        <!--  -->
        <h3>Основи функцій. The basics of functions.</h3>
        <h4>Оголошення та виклик функції. Declaring and calling functions.</h4>
        <p>Cтруктура оголошення функції</p>
        <ol>
          <li>Ключове слово function</li>
          <li>
            Ім'я функції — дієслово, що відповідає на питання "Що зробити?"
          </li>
          <li>Пара круглих дужок ()</li>
          <li>Тіло функції у фігурних дужках {}</li>

          <code>
            <pre>
    function doStuff() {
  // Тіло функції
  console.log('Log inside multiply function');
}
                  </pre
            >
          </code>
        </ol>
        <p>
          Тіло функції містить інструкції, які потрібно виконати. Ці інструкції
          можуть включати оператори, умовні конструкції, цикли та інші функції.
        </p>
        <p>
          Коли функцію потрібно виконати, вона викликається за допомогою її
          імені та пари круглих дужок.
        </p>
        <code>
          <pre>
    // Оголошення функції multiply
function doStuff() {
  // Тіло функції
  console.log('Log inside multiply function');
}

// Виклики функції multiply
doStuff(); // 'Log inside multiply function'
doStuff(); // 'Log inside multiply function'
doStuff(); // 'Log inside multiply function'
                  </pre
          >
        </code>
        <h4>Параметри та аргументи. Parameters and arguments.</h4>
        <dfn>Параметри</dfn> — це локальні змінні, доступні лише всередині тіла
        функції.
        <p>
          Функція може мати будь-яку кількість параметрів або не мати їх
          взагалі, у такому випадку вказуються порожні круглі дужки.
        </p>

        <code>
          <pre>
        // Оголошення параметрів x, y, z
function multiply(x, y, z) {
  console.log(`Result: ${x * y * z}`);
}
        </pre
          >
        </code>

        <p>
          Під час виклику функції в круглих дужках можна передати аргументи, які
          є значеннями для оголошених параметрів функції.
        </p>

        <code>
          <pre>
    // Оголошення параметрів x, y, z
function multiply(x, y, z) {
  console.log(`Result: ${x * y * z}`);
}

// Передача аргументів
multiply(2, 3, 5); // "Result: 30"
multiply(4, 8, 12); // "Result: 384"
multiply(17, 6, 25); // "Result: 2550"
                  </pre
          >
        </code>
        <h4>Повернення значення. Return value.</h4>
        <p>
          Оператор return використовується для повернення значення з тіла
          функції назад у код, у місце її виклику. Коли інтерпретатор зустрічає
          оператор return, він виходить із функції (припиняє її виконання) і
          повертає вказане після return значення в місце виклику функції.
        </p>

        <code>
          <pre>
    function multiply(x, y, z) {
	const product = x * y * z;
  // Повертаємо результат виразу множення
  return product;
}

// Результат роботи функції можна зберегти у змінну
const result = multiply(2, 3, 5);
console.log(result); // 30
                  </pre
          >
        </code>
        <p>
          Щоб уникнути оголошення зайвої змінної в тілі функції, можна відразу ж
          повертати результат виразу без створення окремої змінної для
          зберігання результату виразу.
        </p>

        <code>
          <pre>
    function multiply(x, y, z) {
  return x * y * z;
}

const result = multiply(2, 3, 5);
console.log(result); // 30
                  </pre
          >
        </code>
        <p>
          Якщо в тілі функції відсутній оператор return або він не вказує на
          конкретне значення, функція поверне спеціальне значення undefined.
        </p>

        <code>
          <pre>
    function multiply(x, y, z) {
	const product = x * y * z;
}

const result = multiply(2, 3, 5);
console.log(result); // undefined
                  </pre
          >
        </code>

        <p>
          Всі інструкції які йдуть після оператора return в тілі функції не
          виконуються.
        </p>

        <code>
          <pre>
    function multiply(x, y, z) {
  console.log('The code before return is executed as usual');

  return x * y * z;

  console.log('This code is never executed because it is after return');
}

console.log(multiply(2, 3, 5)); // 30
                  </pre
          >
        </code>
        <h4>Порядок виконання коду. The order of code execution.</h4>
        <p>
          Коли інтерпретатор зустрічає виклик функції, він зупиняє виконання
          поточного коду й починає виконувати код з тіла функції.
        </p>
        <p>
          Після того, як весь код у функції буде виконано, інтерпретатор
          повертає управління в те місце, звідки був здійснений виклик функції,
          і продовжує виконання коду програми, що залишився.
        </p>
        <code>
          <pre>
     function multiply(x, y, z) {
   console.log(`Result: ${x * y * z}`);
  }

  console.log("Log before multiply execution");
  multiply(2, 3, 5); // "Result: 30"
  console.log("Log after multiply execution");
                  </pre
          >
        </code>

        <h4>Область видимості функції. The scope of the function.</h4>
        <p>
          Оголошєна змінна або функцію "видима" в певній частині коду, що
          обумовлюе можливість її використання.
        </p>

        <p>
          Змінні або функції, оголошені поза блоками коду (в глобальній області
          видимості), будуть доступні в будь-якій частині коду - це є глобальні
          змінними.
        </p>
        <p>
          Конструкція, що використовує фігурні дужки {} (умови, цикли, функції
          тощо) створює нову локальну область видимості. Змінні, оголошені в
          локальній області видимості, використовуються тільки всередині цього
          блоку коду.
        </p>
      </div>
    </section>

    <!-- Section two -->
    <section>
      <div class="container">
        <h2>Модуль 2. Розгалуження і цикли</h2>
        <h3>Розгалуження. Branching.</h3>
        <h4>Інструкція if.</h4>
        <p>
          Інструкція <mark><code>if</code></mark> дозволяє виконати певний блок
          коду тільки в тому випадку, якщо задана умова істинна (тобто приймає
          значення <mark><code>true</code></mark
          >).
        </p>

        <code>
          <pre>
     if (condition) {
  // код, який виконується, якщо умова (condition) істинна
}
                  </pre
          >
        </code>
        <p>
          К оли інтерпретатор зустрічає інструкцію <mark><code>if</code></mark
          >, він обчислює вказану умову в круглих дужках (condition),
          перетворюючи її до логічного типу (boolean). Якщо умова (condition)
          перетворюється до true, виконується блок коду, написаний у фігурних
          дужках <mark><code>{}</code></mark> — (statement).
        </p>

        <p>
          Якщо умова (condition) перетворюється до
          <mark><code>false</code></mark
          >, блок коду не виконається і продовжиться виконання програми, що іде
          після інструкції <mark><code>if.</code></mark>
        </p>
        <p>
          Якщо subscription — це "pro", тобто, умова перетворюється до true,
          price встановлюється 100.
        </p>

        <code>
          <pre>
let price = 0;
const subscription = "pro";

if (subscription === "pro") {
  price = 100;
}

console.log(price); // 100
                  </pre
          >
        </code>

        <code>
          <pre>
let price = 0;
const subscription = "free";

if (subscription === "pro") {
  price = 100;
}

console.log(price); // 0
                  </pre
          >
        </code>

        <p>
          Якщо умова перетворюється до <code>false</code>, код у фігурних дужках
          не буде виконуватися і <code>price</code> залишиться рівним 0.
        </p>

        <code>
          <pre>
function checkAge(age) {
  if (age >= 18) {
    return "You are an adult";
  }
}

// Перевірка функції
console.log(checkAge(20)); // "You are an adult"
console.log(checkAge(17)); // undefined
console.log(checkAge(10)); // undefined
console.log(checkAge(30)); // "You are an adult"
                  </pre
          >
        </code>

        <h4>Метод innerHTML</h4>
        <div id="output1"></div>
        <div id="output2"></div>
        <div id="output3"></div>
        <div id="output4"></div>

        <h4>Завдання</h4>
        <p>
          Доповнити код функції <code>checkAge(age)</code> так, щоб функція
          повертала рядок <code>"You are an adult"</code>, якщо значення
          параметра age більше або дорівнює <code>18</code>. Використай у тілі
          функції інструкцію <code>if</code> для перевірки значення age.
        </p>

        <code>
          <pre>
function checkAge(age) {
  if (age >= 18) {
    return "You are an adult";
  }
}

console.log(checkAge(20));
console.log(checkAge(17));
console.log(checkAge(10));
console.log(checkAge(30));

                  </pre
          >
        </code>

        <h4>Інструкція if...else</h4>
        <p>
          Синтаксис інструкції <code>if</code> можна доповнити блоком
          <code>else</code> для визначення альтернативних варіантів виконання
          коду.
        </p>

        <code>
          <pre>
if (condition) {
  // код, який виконується, якщо умова істинна
} else {
	// код, який виконується, якщо умова хибна
}
                  </pre
          >
        </code>

        <h4>Завдання 3</h4>
        <p>
          Якщо умова <code>(condition)</code> перетворюється до
          <code>true</code>, то виконається код блоку <code>if</code>
          <code>(if block statements)</code>.
        </p>
        <p>
          Якщо умова <code>(condition)</code> перетворюється до
          <code>false</code>, то виконається код блоку
          <code>else (else block statements)</code>.
        </p>

        <p>
          Функція checkStorage(available, ordered) перевіряє можливість
          оформлення замовлення і повертає повідомлення про результат. Вона
          оголошує два параметри, значення яких будуть задаватися під час її
          виклику:
        </p>

        <p>available - доступна кількість товарів на складі</p>
        <p>ordered - кількість одиниць товару в замовленні</p>
        <p>
          Використовуючи розгалуження, доповни код функції таким чином, щоб:
        </p>

        <p>
          Якщо в замовленні вказане число, яке перевищує доступну кількість
          товарів на складі, функція повертає рядок "Not enough goods in stock!"
        </p>
        <p>
          В іншому випадку функція повертає рядок "Order is processed, our
          manager will contact you"
        </p>

        <code>
          <pre>
function checkStorage(available, ordered) {
  if (ordered > available) {
    return "Not enough goods in stock!";
  } else {
    return "Order is processed, our manager will contact you";
  }
}

console.log(checkStorage(100, 50));
console.log(checkStorage(100, 130));
console.log(checkStorage(200, 20));
console.log(checkStorage(200, 150));
console.log(checkStorage(150, 180));</pre
          >
        </code>

        <h4>Блок else...if</h4>
        <p>
          Конструкція <code>else...if</code> розширює конструкцію
          <code>if...else</code> і дозволяє перевірити та зреагувати на
          виконання або невиконання кількох умов.
        </p>

        <code>
          <pre>
if (condition_1) {
  // код, який виконується, якщо умова (condition_1) істинна
} else if (condition_2) {
  // код, який виконується, якщо умова (condition_2) істинна
} else if (condition_3) {
  // код, який виконується, якщо умова (condition_3) істинна
} else {
	// код, який виконується, якщо всі умови хибні
}
</pre
          >
        </code>
        <p>Кожна умова послідовно перевіряється зверху вниз.</p>
        <p>
          Якщо умова <code>condition_1</code> істинна, виконується відповідний
          блок коду (тільки тіло відповідного блоку <code>if</code> або
          <code>else if</code>), і перевірка завершується.
        </p>
        <p>
          Якщо умова <code>condition_1</code> хибна, то перевіряється умова_2 і
          далі.
        </p>
        <p>
          Код у блоці else буде виконаний тільки у випадку, якщо жодна з умов у
          блоках <code>if</code> та <code>else if</code> не є істинною.
        </p>

        <p>
          У цьому прикладі спочатку перевіряється умова
          <code>grade >= 90</code>.
        </p>

        <!-- else if -->
        <code>
          <pre>
const grade = 85;

if (grade >= 90) {
  console.log("Perfectly");
} else if (grade >= 80) {
  console.log("Good");
} else if (grade >= 70) {
  console.log("Satisfactorily");
} else {
  console.log("Unsatisfactorily");
}
</pre
          >
        </code>

        <!-- Завдання 3 -->

        <p>
          Функція <code>checkStorage(available, ordered)</code> перевіряє
          можливість оформлення замовлення і повертає повідомлення про
          результат. Вона оголошує два параметри, значення яких будуть
          задаватися під час її виклику.
        </p>

        <p><code>available</code> - доступна кількість товарів на складі</p>
        <p><code>ordered</code> - кількість одиниць товару в замовленні</p>
        <p>
          Використовуючи розгалуження, доповни код функції таким чином, щоб:
        </p>

        <p>
          Якщо в замовленні ще немає товарів, тобто значення параметра
          <code>ordered</code> дорівнює <code>0</code>, функція повертає рядок
          <code>"There are no products in the order!"</code>.
        </p>
        <p>
          Якщо товарів у замовленні більше, ніж їх доступно на складі, то
          функція повертає рядок
          <code
            >"Your order is too large, there are not enough items in
            stock!"</code
          >.
        </p>
        <p>
          В іншому випадку функція повертає рядок
          <code>"The order is accepted, our manager will contact you"</code>.
        </p>

        <code>
          <pre>
function checkStorage(available, ordered) {
  if (ordered === 0) {
    return "There are no products in the order!";
  } else if (ordered > available) {
    return "Your order is too large, there are not enough items in stock!";
  } else {
    return "The order is accepted, our manager will contact you";
  }
}

// Перевірка функції
console.log(checkStorage(100, 50)); // "The order is accepted, our manager will contact you"
console.log(checkStorage(100, 130)); // "Your order is too large, there are not enough items in stock!"
console.log(checkStorage(70, 0)); // "There are no products in the order!"
console.log(checkStorage(200, 20)); // "The order is accepted, our manager will contact you"
console.log(checkStorage(200, 250)); // "Your order is too large, there are not enough items in stock!"
console.log(checkStorage(150, 0)); // "There are no products in the order!"
console.log(checkStorage(80, 80)); // "The order is accepted, our manager will contact you"
</pre
          >
        </code>

        <h3>Тернарний оператор. Ternary operator.</h3>
        <p>
          <dfn>Тернарний оператор</dfn> — це коротша синтаксична заміна
          інструкції if...else.
        </p>

        <code>
          <pre>
&lt;condition&gt; ? &lt;expression if condition is true&gt; : &lt;expression if condition is false&gt;
          </pre>
        </code>
        <p>Код з використанням інструкції if...else</p>
        <code>
          <pre>
let type;
const age = 20;

if (age >= 18) {
  type = 'adult';
} else {
  type = 'child';
}

console.log(type); // 'adult'

          </pre>
        </code>

        <p>Той самий код з використанням тернарного оператора:</p>
        <code>
          <pre>
const age = 20;
const type = age >= 18 ? 'adult' : 'child';
console.log(type); // 'adult'
          </pre>
        </code>

        <p>
          Знаходження більшого числа із двох з використанням інструкції
          <code>if...else</code>:
        </p>
        <code>
          <pre>
const a = 5;
const b = 10;
let biggerNumber;

if (a > b) {
  biggerNumber = a;
} else {
  biggerNumber = b;
}

console.log(biggerNumber); // 10
          </pre>
        </code>
        <p>Той самий код з використанням тернарного оператора:</p>
        <code>
          <pre>
const a = 5;
const b = 10;
const biggerNumber = a > b ? a : b;

console.log(biggerNumber); // 10
          </pre>
        </code>
        <p>
          Тернарний оператор рекомендується використовувати у найпростіших
          випадках операції присвоєння чи повернення. Однак не рекомендується
          використовувати його для складних розгалужень, оскільки це може
          ускладнити читання та розуміння коду.
        </p>
        <p>
          Функція checkPassword(password) порівнює переданий їй пароль (параметр
          password) зі збереженим паролем адміністратора (correctPassword) і
          повертає рядок з повідомленням про результат.
        </p>
        <p>
          Використовуючи тернарний оператор, доповни функцію таким чином, щоб:
        </p>
        <p>
          Якщо значення password і correctPassword збігаються, функція повертала
          рядок "Access granted"
        </p>
        <p>
          В іншому випадку, функція повертала рядок "Access denied, wrong
          password!"
        </p>

        <code>
          <pre>
function checkPassword(password) {
  const correctPassword = "jqueryismyjam";
  
  return password === correctPassword 
    ? "Access granted" 
    : "Access denied, wrong password!";
}

console.log(checkPassword("jqueryismyjam"));
console.log(checkPassword("angul4r1sl1f3"));
console.log(checkPassword("r3actsux"));
          </pre>
        </code>

        <h3>Оператор switch</h3>
        <p>
          Використання switch є більш компактним і зручним способом для
          порівняння виразів з кількома варіантами, ніж інструкції if...else та
          else...if.
        </p>
        <h4>Приклад використання оператора <code>switch:</code></h4>

        <code>
          <pre>
const fruit = 'apple';

switch (fruit) {
  case 'apple':
    console.log('Apple selected');
    break;
  case 'banana':
    console.log('Banana selected');
    break;
  case 'orange':
    console.log('Orange selected');
    break;
  default:
    console.log('The fruit is unknown');
}
          </pre>
        </code>
        <h4>Оператор break</h4>
        <p>
          Якщо break не вказано, виконання коду продовжиться в наступному
          <mark>case</mark> і далі. Така поведінка називається "провалюванням"
          (<mark>fall-through</mark>). Якщо потрібно, щоб кілька блоків case
          виконували той самий код, можна опустити оператор break між ними.
        </p>

        <code>
          <pre>
const day = 3;

switch (day) {
  case 1:
  case 2:
  case 3:
  case 4:
  case 5:
    console.log('This is a working day');
    break;
  case 6:
  case 7:
    console.log('It is a day off');
    break;
  default:
    console.log('Invalid');
}
          </pre>
        </code>

        <p>
          Функція getSubscriptionPrice(type) отримує рядок з типом передплати
          користувача (параметр type), перевіряє її на збіг з трьома можливими
          типами щомісячної передплати та повертає ціну, або повідомлення про
          неправильний тип передплати.
        </p>

        <p>Якщо значення параметра type — це рядок:</p>

        <p>"starter" — ціна передплати 0 кредитів.</p>
        <p>"professional" — ціна передплати 20 кредитів.</p>
        <p>"organization" — ціна передплати 50 кредитів.</p>
        <p>
          Для будь-якого іншого значення параметра type повертається рядок
          "Invalid subscription type!".
        </p>

        <p>Використання оператора switch для розв'язання цієї задачі!</p>
        <code>
          <pre>
function getSubscriptionPrice(type) {
  switch (type) {
    case "starter":
      return 0;
    case "professional":
      return 20;
    case "organization":
      return 50;
    default:
      return "Invalid subscription type!";
  }
}

console.log(getSubscriptionPrice("professional"));
console.log(getSubscriptionPrice("organization"));
console.log(getSubscriptionPrice("starter"));
console.log(getSubscriptionPrice("random"));
console.log(getSubscriptionPrice("premium"));
          </pre>
        </code>
        <h4>
          Пам’ятка під час використання розгалужень. A reminder when using
          branches.
        </h4>
        <p>
          Інструкція if є універсальною. Інструкції if…else і else…if
          використовуються, коли потрібно прописати декілька умов. Отже, ці
          інструкції зазвичай довші, ніж інші способи розгалужень.
        </p>
        <p>
          Тернарний оператор краще використовувати для присвоєння або повернення
          значення з тіла функції. В умові тернарного оператора може бути все що
          завгодно: перевірка рівності / нерівності, на більше / менше, просто
          перевірка на будь чого. Пам’ятай про обмеження: у нього має бути рівно
          2 сценарії, не більше.
        </p>
        <p>
          Оператор switch перевіряє тільки на сувору рівність. Використовуючи
          оператор switch, завжди: пам’ятай про оператор break; використовуй
          тільки 1 default, він завжди має бути останнім.
        </p>
        <h4>Блокова область видимості. Blocked viewport.</h4>
        <p>
          Під час оголошення змінної або функції, вона стає "видимою" тільки в
          певній частині коду.
        </p>
        <p>
          Змінні або функції, які оголошені поза будь-якими блоками коду — тобто
          в глобальній області видимості є глобальними змінними і будуть
          доступні в будь-якій частині коду.
        </p>
        <code>
          <pre>
// Глобальна змінна
const value = "I'm a global variable";

if (true) {
	// Можна звернутися до глобальної змінної
  console.log(value); // "I'm a global variable"
}

// Можна звернутися до глобальної змінної
console.log(value); // "I'm a global variable"
          </pre>
        </code>
        <p>
          Змінна value оголошена в глобальній області видимості (поза блоком
          коду), вона буде доступна в будь-якому місці після оголошення.
        </p>
        <p>
          Будь-яка конструкція, що використовує фігурні дужки {} (умови,
          функції, цикли тощо) створює нову локальну блочну область видимості.
          Змінні, оголошені в цій області видимості, можуть бути використані
          тільки всередині цього блоку коду. Це локальні змінні.
        </p>
        <code>
          <pre>
if (true) {
  // Локальна змінна
	const value = "I'm a local variable";
  console.log(value); // "I'm a local variable"
}

// Помилка: локальну змінну не видно за межами блоку
console.log(value); // ReferenceError: value is not defined
          </pre>
        </code>
        <p>
          Область видимості не має доступу до змінних, що оголошені у вкладених
          областях видимості.
        </p>
        <p>
          Код у блоці A має доступ до змінних, оголошених у Global, але не має
          доступу до змінних, оголошених у блоках B і C.
        </p>
        <p>
          Код у блоці B має доступ до змінних, оголошених у Global і в блоці A,
          але не має доступу до змінних, оголошених у блоці C.
        </p>
        <p>
          Код у блоці C має доступ до змінних, оголошених у Global, але не має
          доступу до змінних, оголошених у блоках A і B.
        </p>
        <code>
          <pre>
const globalVar = "Global";

console.log(globalVar); // Доступ до globalVar з глобальної області видимості
// Немає доступу до aVar, bVar і cVar

if(true) {
	const aVar = "A";
	console.log(globalVar); // Доступ до globalVariable з блоку A
  console.log(aVar); // Доступ до aVar з блоку A
	// Немає доступу до bVar і cVar

	if(true) {
		const bVar = "B";
		console.log(globalVar); // Доступ до globalVariable з блоку B
	  console.log(aVar); // Доступ до aVar з блоку B
	  console.log(bVar); // Доступ до bVar з блоку B
		// Немає доступу до cVar
	}
}

console.log(globalVar); // Доступ до globalVar із глобальної області видимості
// Немає доступу до aVar, bVar і cVar

if(true) {
	const cVar = "C";
  console.log(globalVariable); // Доступ до globalVar з блоку C
  console.log(cVar); // Доступ до cVar з блоку C
	// Немає доступу до aVar і bVar
}

console.log(globalVar); // Доступ до globalVar із глобальної області видимості
// Немає доступу до aVar, bVar і cVar
          </pre>
        </code>
        <h2>Логічні оператори. Logical operators.</h2>
        <p>
          <dfn>Логічне перетворення типів</dfn> означає приведення значення
          будь-якого типу даних у логічне (булеве) значення
          <code>true</code> або <code>false</code>. Існує кілька правил, які
          визначають, які значення перетворюються на <code>true</code>, а які на
          <code>false</code>.
        </p>
        <p>
          Ці правила працюють як для явного перетворення типів за допомогою
          функції <code>Boolean()</code>, так і для неявного в умовних
          операціях, наприклад, у конструкціях <code>if</code> чи логічних
          операторах.
        </p>
        <p>
          Логічні значення <code>true</code> та <code>false</code> залишаються
          незмінними.
        </p>
        <code>
          <pre>
console.log(Boolean(true)); // true
console.log(Boolean(false)); // false
          </pre>
        </code>
        <p>
          Число <code>0</code>, значення <code>NaN</code>, <code>null</code> і
          undefined завжди перетворюються на <code>false</code>. Усі інші числа
          перетворюються на <code>true</code>.
        </p>
        <code>
          <pre>
console.log(Boolean(NaN)); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean(0)); // false
console.log(Boolean(3.14)); // true
console.log(Boolean(-10)); // true
          </pre>
        </code>
        <p>
          У прикладі нижче начення в умові інструкцій if приводиться до false,
          отже, виконується код із блоку else.
        </p>
        <code>
          <pre>
if(null) {
	console.log("Block if")
} else {
	console.log("Block else")
}

if(0) {
	console.log("Block if")
} else {
	console.log("Block else")
}
          </pre>
        </code>
        <p>
          Значення в умові інструкції if приводиться до true, отже, виконується
          код із блоку if.
        </p>
        <code>
          <pre>
if(5) {
	console.log("Block if")
} else {
	console.log("Block else")
}
          </pre>
        </code>
        <h4>6 випадків, які приводяться до false:</h4>
        <p>1. 0</p>
        <p>2. ""</p>
        <p>3. Nan</p>
        <p>4. null</p>
        <p>5. underfined</p>
        <p>6. false</p>

        <p>
          <dfn>Оператор "І" (&&)</dfn> наводить усі операнди до логічного типу
          (<code>true</code> або <code>false</code>) і повертає значення одного
          з них. Дозволяє перевірити, чи виконані всі умови у виразі.
        </p>
        <p>
          <dfn>Оператор “І”</dfn> зліва направо перевіряє почергово обидва
          операнди на істинність та повертає або значення останнього істинного
          (тільки правого) операнда, або першого хибного (лівого чи правого), на
          якому він запнувся.
        </p>
        <code>
          <pre>
console.log("hello" && 5); // 5
console.log(5 && "hello"); // "hello"

console.log("mango" && "poly"); // "poly"
console.log("poly" && "mango"); // "mango"

console.log(3 && true); // true
console.log(true && 3); // 3
          </pre>
        </code>
        <p>
          у цьому прикладі один із операндів буде приведений до false, отже,
          результатом буде хибний операнд.
        </p>
        <code>
          <pre>
console.log("hello" && 0); // 0
console.log(0 && "hello"); // 0

console.log(3 && false); // false
console.log(false && 3); // false

console.log(0 && ""); // 0
console.log("" && 0); // ""
          </pre>
        </code>
        <p>
          У прикладі <code>“hello” && 0</code> лівий операнд приводиться до
          true, а правий до <code>false</code>, тому результатом виразу буде
          значення правого операнда, який першим був приведений до false, тобто
          <code>0</code>.
        </p>
        <p>
          У приклад <code>0 && “hello”</code> лівий операнд приводиться до
          <code>false</code>, тому правий операнд не буде обчислюватися.
          Результатом виразу буде значення лівого операнда, який першим був
          приведений до <code>false</code>, тобто <code>0</code>.
        </p>
        <p>
          якщо операндами є вирази, то спочатку вони обчислюються, а потім їх
          результати будуть порівнюватися оператором &&.
        </p>

        <h3>Логічне "АБО"</h3>
        <p>
          <dfn>Оператор "АБО" (||)</dfn> перетворює всі операнди до логічного
          типу (true або false), перевіряє чи є хочаб один із операдів "true",
          та і повертає значення одного з них. Якщо хоча б один із операндів
          можна перетворити на true, результатом логічного «АБО» буде true.
        </p>
        <code>
          <pre>
console.log("hello" && 0); // 0
cexpression1 || expression2
          </pre>
        </code>

        <code>
          <pre>
console.log(true || false); // true
console.log(false || true); // true

console.log(5 || false); // 5
console.log(false || 5); // 5

console.log("hello" || 0); // "hello"
console.log(0 || "hello"); // "hello"
          </pre>
        </code>
        <p>
          Якщо до істини було перетворено перший операнд, то другий навіть не
          буде оцінюватися. Це може мати практичне застосування, особливо коли
          другий операнд є виразом, який має високу вартість обчислення.
        </p>
        <code>
          <pre>
console.log(5 || 3); // 5
console.log(3 || 5); // 3

console.log("mango" || "poly"); // "mango"
console.log("poly" || "mango"); // "poly"
          </pre>
        </code>

        <p>
          Якщо всі операнди перетворюються на false, результатом буде значення
          крайнього правого операнда.
        </p>
        <code>
          <pre>
console.log(0 || false); // false
console.log(false || 0); // 0

console.log(null || ""); // ""
console.log("" || null); // null
          </pre>
        </code>
        <p>
          На практиці оператор «АБО» також використовується для перевірки
          множинних умов.
        </p>
        <code>
          <pre>
const a = 5;
console.log(a &lt; 10 || a &gt; 30); // true || false -&gt; true

const b = 50;
console.log(b &lt; 10 || b > 30); // false || true -&gt; true

const c = 20;
console.log(c - 20 || c * 2); // 0 || 40 -&gt; 40
          </pre>
        </code>

        <p>В умові інструкції if.</p>
        <code>
          <pre>
const screenWidth = 700;
const sm = 320;
const md = 768;
const lg = 1200;

if(screenWidth &lt;= sm || screenWidth > md) {
	console.log("Mobile or Desktop screen");
  // у консолі буде пусто, оскільки жодна з умов не перетворилась на true
}
          </pre>
        </code>
        <p>
          Функція <code>checkAccess(subType)</code> перевіряє, чи може
          користувач отримати доступ до контенту. Перевірка відбувається за
          типом передплати. Використовуючи оператор "АБО", доповни код функції
          так, щоб якщо значення параметра <code>subType</code> дорівнює рядкам
          <code>"pro"</code> або <code>"vip"</code>, то функція повертала
          <code>true</code> і користувач отримував доступ. В іншому випадку
          повертала <code>false</code>.
        </p>
        <code>
          <pre>
function checkAccess(subType) {
  return subType === "pro" || subType === "vip";
}

// Перевірка функції
console.log(checkAccess("pro")); // true
console.log(checkAccess("starter")); // false
console.log(checkAccess("vip")); // true
console.log(checkAccess("free")); // false
          </pre>
        </code>
        <p>
          <dfn>Логічне «НІ» (!)</dfn> — це унарний оператор — він виконує
          операцію над одним операндом праворуч. Логічне «НІ» приводить операнд
          до логічного значення (true або false) і потім заперечує (інвертує)
          його, тобто заміняє на протилежне: true —> false, а false —> true.
        </p>
        <code>
          <pre>
console.log(!true); // false
console.log(!false); // true
console.log(!3); // !3 -> !true -> false
console.log(!"Mango"); // !"Mango" -> !true -> false
console.log(!0); // !0 -> !false -> true
console.log(!""); // !"" -> !false -> true
console.log(!null); // !null -> !false -> true
          </pre>
        </code>
        <p>
          На практиці логічне заперечення використовується для перевірки від
          зворотного. Наприклад, можна дозволити написати повідомлення в чаті,
          лише якщо користувач не заблокований.
        </p>
        <code>
          <pre>
const isBlocked = false;
const canChat = !isBlocked; // !false -> true

if(canChat) {
	console.log("Can type in chat!")
} else {
	console.log("Blocked from typing in chat!")
}
          </pre>
        </code>

        <p>
          Функція <code>toggleModalVisibility(isVisible)</code> перемикає стан
          відображення модального вікна. У параметрі <code>isVisible</code> вона
          очікує буль <code>true</code> або <code>false</code>. Доповни код
          функції так, щоб вона повертала протилежне значення цього параметра.
        </p>
        <pre>
      <code>
function toggleModalVisibility(isVisible) {
return !isVisible;
}

console.log(toggleModalVisibility(true)); // false
console.log(toggleModalVisibility(false)); // true
      </code>
        </pre>

        <p>В JS загалом 8 видів типів даних.</p>
        <p>
          Низка функций присутня тільки в браузері. Наприклад: alert('text');
        </p>
        <h3>Прикдади використання JavaScript в html документі</h3>
        <p>Властивості — це описові характеристики сутності.</p>
        <p>Методи — це дії, які можна виконати із сутністю.</p>
        <p>Щоб отримати довжину рядка, використовується властивість length:</p>
        <pre>
      <code>
const message = "JavaScript is awesome";
console.log(message.length); // 21
      </code>
        </pre>
        <p>
          Виклик методу схожий на доступ до властивості, але наприкінці
          додаються круглі дужки, як при виклику функції:
        </p>
        <pre>
      <code>
objectName.method()
      </code>
        </pre>
        <pre>
      <code>
const message = "JavaScript is awesome";
console.log(message.toUpperCase()); // "JAVASCRIPT IS AWESOME"
      </code>
        </pre>
        <p>
          <dfn>Метод slice()</dfn> використовується для створення копії частини
          або всього рядка без зміни оригінального рядка. Він дозволяє
          витягувати підрядок з вихідного рядка, вказуючи початковий та кінцевий
          індекси.
        </p>
        <pre>
      <code>
const fullName = "Jacob Mercer";
console.log(fullName.slice(0, 4)); // 'Jaco'
console.log(fullName.slice(3, 9)); // 'ob Mer'
console.log(fullName.slice(0, fullName.length)); // 'Jacob Mercer'
      </code>
        </pre>
        <p>
          Якщо <code>endIndex</code> не вказаний, витягуються всі елементи до
          кінця рядка.
        </p>
        <pre>
      <code>
const fullName = "Jacob Mercer";
console.log(fullName.slice(1)); // 'acob Mercer'
console.log(fullName.slice(3)); // 'ob Mercer'
      </code>
        </pre>
        <p>
          Якщо викликати метод <code>slice()</code> без аргументів, він створює
          точну копію рядка і повертає її.
        </p>
        <pre>
      <code>
const fullName = "Jacob Mercer";
console.log(fullName.slice()); // 'Jacob Mercer'
      </code>
        </pre>
        <p>
          Результат виклику методу <code>slice()</code> можна зберігати в
          змінній для подальшого використання.
        </p>
        <pre>
      <code>
const fullName = "Jacob Mercer";
const firstName = fullName.slice(0, 5);
const lastName = fullName.slice(6);

console.log(fullName); // "Jacob Mercer"
console.log(firstName); // "Jacob"
console.log(lastName); // "Mercer"
      </code>
        </pre>

        Ф
        <p>
          Ф ункція getSubstring(string, length) приймає рядок і повертає новий
          підрядок (його часткову копію). Вона оголошує два параметри, значення
          яких будуть задаватися під час її виклику: Ф
        </p>
        <p>string - оригінальний рядок</p>
        <p>length - довжина нового підрядка</p>
        <p>
          Доповни код функції так, щоб вона повертала новий підрядок, який
          починається від початку string і має довжину length.
        </p>
        <pre>
      <code>
function getSubstring(string, length) {
  return string.substring(0, length);
}

console.log(getSubstring('Hello world', 3)); // "Hel"
console.log(getSubstring('Hello world', 5)); // "Hello"
console.log(getSubstring('Hello world', 8)); // "Hello wo"
console.log(getSubstring('Hello world', 11)); // "Hello world"
console.log(getSubstring('Hello world', 0)); // ""
      </code>
        </pre>
        <h3>Методи toLowerCase() і toUpperCase()</h3>
        <p>
          Метод <code>toLowerCase()</code> повертає новий рядок, у якому всі
          символи вихідного рядка перетворені в нижній регістр.
        </p>
        <pre>
      <code>
const message = "Welcome to Bahamas!";
console.log(message.toLowerCase()); // "welcome to bahamas!"
console.log(message); // "Welcome to Bahamas!"
      </code>
        </pre>
        <p>
          Метод <code>toUpperCase()</code> повертає новий рядок, у якому всі
          символи вихідного рядка перетворені у верхній регістр.
        </p>
        <pre>
      <code>
const message = "Welcome to Bahamas!";
console.log(message.toUpperCase()); // "WELCOME TO BAHAMAS!"
console.log(message); // "Welcome to Bahamas!"
      </code>
        </pre>
        <p>
          Розгляньмо ситуацію: При пошуку за ключовим словом, користувач вводить
          рядок 'saMsUng', а його треба порівняти з рядком 'samsung' або
          'SAMSUNG'.
        </p>
        <pre>
      <code>
console.log('saMsUng' === 'samsung'); // false
console.log('saMsUng' === 'SAMSUNG'); // false
      </code>
        </pre>
        <p>
          Щоб не вимагати абсолютно точного введення, можна зробити
          «нормалізацію» введеного користувачем рядка, тобто перетворити всі
          його символи у верхній або нижній регістр.
        </p>
        <pre>
      <code>
const brandName = 'samsung';
const userInput = 'saMsUng';
const lowercaseInput = userInput.toLowerCase();

console.log(brandName); // 'samsung'
console.log(userInput); // 'saMsUng'
console.log(userInput === brandName); // false
console.log(lowercaseInput); // 'samsung'
console.log(lowercaseInput === brandName); // true
      </code>
        </pre>
        <p>Функція normalizeInput(input, to) оголошує два параметри:</p>

        <p>input - рядок, який потрібно привести до певного регістру</p>
        <p>
          to - рядок с двома можливими значеннями: "upper" або "lower", що
          вказують до якого регістру потрібно привести значення input
        </p>
        Доповни код функції таким чином, щоб:

        <p>
          Якщо значення параметра to — це рядок "upper", то функція повертала
          копію рядка input, але у верхньому регістрі
        </p>
        <p>
          В іншому разі, функція повертала копію рядка inputу нижньому регістрі
        </p>
        <pre>
      <code>
function normalizeInput(input, to) {
  return to === "upper" ? input.toUpperCase() : input.toLowerCase();
}

// Приклади виклику функції та їх результати:
console.log(normalizeInput("This ISN'T SpaM", "lower")); // "this isn't spam"
console.log(normalizeInput("This ISN'T SpaM", "upper")); // "THIS ISN'T SPAM"
console.log(normalizeInput("Big SALE", "lower")); // "big sale"
console.log(normalizeInput("Big SALE", "upper")); // "BIG SALE"
console.log(normalizeInput("Stay Awhile and Listen", "lower")); // "stay awhile and listen"
console.log(normalizeInput("Stay Awhile and Listen", "upper")); // "STAY AWHILE AND LISTEN"
      </code>
        </pre>
        <ol>
          <li>
            Параметри функції:
            <ul>
              <li>input: Рядок, який потрібно перетворити.</li>
              <li>
                to: Рядок, який визначає, чи потрібно перетворити input на
                верхній або нижній регістр. Він може мати два значення: "upper"
                або "lower".
              </li>
            </ul>
          </li>
          <li>
            Умовний (тернарний) оператор:
            <ul>
              <li>
                to === "upper": Це умова, яка перевіряє, чи дорівнює значення
                параметра to рядку "upper".
              </li>
              <li>
                ?: Якщо умова істинна (тобто to === "upper"), виконується вираз
                після знака питання (input.toUpperCase()).
              </li>
              <li>
                :: Якщо умова хибна (тобто to !== "upper"), виконується вираз
                після двокрапки (input.toLowerCase()).
              </li>
            </ul>
          </li>
          <li>
            Методи toUpperCase() та toLowerCase():
            <ul>
              <li>
                input.toUpperCase(): Приводить всі символи в рядку input до
                верхнього регістру.
              </li>
              <li>
                input.toLowerCase(): Приводить всі символи в рядку input до
                нижнього регістру.
              </li>
            </ul>
          </li>
        </ol>
        <p>Як працює функція:</p>
        <ul>
          <li>
            кщо параметр to дорівнює "upper", функція повертає рядок input,
            перетворений на верхній регістр.
          </li>
          <li>
            Якщо to не дорівнює "upper" (наприклад, "lower" або будь-яке інше
            значення), функція повертає рядок input, перетворений на нижній
            регістр.
          </li>
        </ul>
        <p>Приклад:</p>
        <ul>
          <li>Виклик normalizeInput("Hello", "upper") поверне "HELLO".</li>
          <li>Виклик normalizeInput("Hello", "lower") поверне "hello".</li>
        </ul>

        <h3>Метод includes()</h3>

        <p>
          Метод рядків <code>includes()</code> використовується для перевірки
          наявності підрядка у рядку. Він повертає логічне значення
          <code>true</code>, якщо підрядок знайдено, і <code>false</code>, якщо
          підрядок відсутній.
        </p>
        <pre>
      <code>
str.includes(substring)
      </code>
        </pre>
        <p>str — вихідний рядок, у якому ми шукаємо підрядок;</p>
        <p>substring — підрядок, який ми хочемо знайти у вихідному рядку.</p>
        <pre>
      <code>
const username = 'Jacob Mercer';

console.log(username.includes('Jacob')); // true
console.log(username.includes('John')); // false
console.log(username.includes('Mercer')); // true
console.log(username.includes('Doe')); // false
      </code>
        </pre>
        <p>
          Регістр символів у рядку й підрядку має значення. Літера
          <code>a</code>, наприклад, не дорівнює літері <code>A</code>.
        </p>

        <pre>
      <code>
function checkForName(fullName, firstName) {
  // Приводимо обидва рядки до нижнього регістру
  const normalizedFullName = fullName.toLowerCase();
  const normalizedFirstName = firstName.toLowerCase();
  
  // Перевіряємо, чи входить firstName у fullName
  return normalizedFullName.includes(normalizedFirstName);
}

console.log(checkForName("Jason Neis", "Jason")); // Повертає true
console.log(checkForName("Jason Neis", "jAsOn")); // Повертає true
console.log(checkForName("Jason Neis", "Jacob")); // Повертає false
console.log(checkForName("Caty Stars", "Caty"));  // Повертає true
console.log(checkForName("Caty Stars", "cAtY"));  // Повертає true
console.log(checkForName("Caty Stars", "Andromeda")); // Повертає false
      </code>
        </pre>
        <h3>Методи startsWith() і endsWith()</h3>
        <p>
          Методи <code>startsWith()</code> і <code>endsWith()</code> призначені
          для перевірки початку й закінчення рядка відповідно. Вони повертають
          булеве значення <code>true</code> або <code>false</code>, залежно від
          того, чи відповідає початок або кінець рядка заданому значенню.
        </p>

        <pre>
      <code>
const str = "Hello, world!";

console.log(str.startsWith("Hello")); // true
console.log(str.startsWith("hello")); // false (метод чутливий до регістру)
      </code>
        </pre>

        <pre>
      <code>
const str = "Hello, world!";

console.log(str.endsWith("world!")); // true
console.log(str.endsWith("World!")); // false (метод чутливий до регістру)
      </code>
        </pre>
        <p>Функція checkFileExtension(fileName, ext) приймає два параметри:</p>

        <p>
          fileName - рядок, що зберігає ім'я файлу з розширенням, наприклад,
          styles.css, hello.js тощо.
        </p>
        <p>ext - рядок, що зберігає розширення, наприклад, .css, .js тощо</p>
        <p>Доповни код функції так, щоб:</p>

        <p>
          Якщо ім'я файлу fileName закінчується розширенням, зазначеним у
          параметрі ext, то функція повертала рядок "File extension matches"
        </p>
        <p>
          В іншому разі, функція повертала рядок "File extension does not match"
        </p>
        <pre>
      <code>
function checkFileExtension(fileName, ext) {
  if (fileName.endsWith(ext)) {
    return "File extension matches";
  } else {
    return "File extension does not match";
  }
}

// Приклади виклику функції:
console.log(checkFileExtension("styles.css", ".css")); // "File extension matches"
console.log(checkFileExtension("styles.css", ".js")); // "File extension does not match"
console.log(checkFileExtension("app.js", ".js")); // "File extension matches"
console.log(checkFileExtension("app.js", ".html")); // "File extension does not match"
console.log(checkFileExtension("index.html", ".html")); // "File extension matches"
console.log(checkFileExtension("index.html", ".css")); // "File extension does not match"
console.log(checkFileExtension("index.html", ".js")); // "File extension does not match"
      </code>
        </pre>
        <h3>Метод indexOf()</h3>
        <p>
          Метод indexOf() використовується для пошуку першого входження підрядка
          в рядок. Він повертає:
        </p>
        <p>
          індекс першого входження (індекс першого символу) підрядка, якщо він
          знайдений
        </p>
        <p>або -1, якщо підрядок не виявлено</p>
        <pre>
      <code>
const message = "Welcome to Bahamas!";
const index = message.indexOf("to");
console.log(index); // 8
      </code>
        </pre>
        <pre>
        <code>
const message = "Welcome to Bahamas!";
const index = message.indexOf("hello");
console.log(index); // -1
      </code>
        </pre>
        <p>Функція getFileName(file) приймає один параметр</p>

        <p>file - рядок з іменем файлу.</p>
        <p>
          Ім'я файлу може бути з розширенням, наприклад: styles.css, app.js або
          без, наприклад: styles, app.
        </p>
        <p>
          Використовуючи методи indexOf та slice, доповни код функції таким
          чином, щоб:
        </p>

        <p>
          Вона перевіряла наявність розширення в імені файлу (назва розширення
          відокремлюється від імені файла крапкою)
        </p>
        <p>
          Якщо ім'я файлу не містить розширення, то функція повертала новий
          підрядок, що містить ім'я файлу без змін
        </p>
        <p>
          В іншому разі функція повертала підрядок з іменем файлу, але без
          розширення
        </p>
        <pre>
      <code>
function getFileName(file) {
  const dotIndex = file.indexOf('.'); // Знаходимо позицію першої крапки в імені файлу
  
  if (dotIndex === -1) {
    return file; // Якщо крапки немає, повертаємо ім'я файлу без змін
  } else {
    return file.slice(0, dotIndex); // Якщо крапка є, повертаємо частину рядка до крапки
  }
}

// Приклади виклику функції:
console.log(getFileName("styles.css")); // "styles"
console.log(getFileName("app.js")); // "app"
console.log(getFileName("app")); // "app"
console.log(getFileName("index.js")); // "index"
console.log(getFileName("index.html")); // "index"
console.log(getFileName("index.css")); // "index"
console.log(getFileName("index")); // "index"
      </code>
        </pre>
        <h3>Метод trim()</h3>
        <p>
          Метод trim() використовується для видалення початкових і кінцевих
          пробілів із рядка.
        </p>
        <pre>
      <code>
const input = " JavaScript is awesome!    ";
const trimmedInput = input.trim();
console.log(trimmedInput); // "JavaScript is awesome!"
console.log(input); // " JavaScript is awesome! 
      </code>
        </pre>
        <p>Функція createFileName(name, ext) приймає два параметри:</p>

        <p>
          name - рядок, що зберігає ім'я файлу без розширення, яке вводить
          користувач. Воно може містити зайві пробіли на початку або в кінці
          рядка, наприклад "order ", " finance " тощо
        </p>
        <p>ext - рядок, що зберігає розширення, наприклад "txt", "xml" тощо</p>
        <p>
          Використовуючи синтаксис шаблонних рядків і метод trim(), доповни код
          функції таким чином, щоб вона повертала повне (об'єднане) ім'я файлу з
          доданим розширенням, зазначеним у параметрі ext у форматі
          ім'я.розширення.
        </p>
        <p>
          Також повне ім'я файлу не повинно містити зайвих пробілів на початку
          або наприкінці.
        </p>
        <pre>
      <code>
function createFileName(name, ext) {
  return `${name.trim()}.${ext}`;
}

// Приклади виклику функції:
console.log(createFileName(" order ", "txt")); // "order.txt"
console.log(createFileName("report ", "csv")); // "report.csv"
console.log(createFileName(" presentation", "xml")); // "presentation.xml"
      </code>
        </pre>
      </div>
    </section>
    <script src="js/jsgo.js"></script>
    <script src="js/connect.js" defer></script>
    <script src="js/typeof.js" defer></script>
    <script src="js/sasha.js" defer></script>
    <script src="js/if.js" defer></script>
    <script src="js/good.js" defer></script>
  </body>
</html>
