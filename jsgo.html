<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="css/jsgo.css" />

    <title>JavaScript</title>
  </head>
  <body>
    <section>
      <nav class="nav">
        <h1>JavaScript 3.0</h1>
        <ol>
          <li>
            <a href="#module-one"
              >Модуль 1. Змінні та типи. Основи функцій. Module 1: Variables and
              types. The basics of functions.</a
            >
          </li>
          <li><a href="#"></a></li>
          <li><a href="#"></a></li>
          <li><a href="#"></a></li>
          <li><a href="#"></a></li>
        </ol>
      </nav>
    </section>

    <section>
      <div class="container">
        <h3>
          Інструкції для роботи с консолью в браузері. Instructions for working
          with the console in a browser.
        </h3>
        <p>Прописати в браузері <mark>about:blank</mark></p>
        <p>
          Прописати <mark>allow pasting</mark> (яущо треба) щоб дозволити
          вставлення коду.
        </p>
        <p>
          <mark>console.clear()</mark> - це треба прописати в консолі, щоб
          видалити з нього код.
        </p>

        <p id="lit"></p>
        <p id="global"></p>
        <p id="defined"></p>

        <h2 id="module-one">
          Модуль 1. Змінні та типи. Основи функцій. Module 1: Variables and
          types. The basics of functions.
        </h2>

        <h3>Базова термінологія JavaScript. Basic JavaScript terminology.</h3>

        <p>
          <dfn>Код</dfn> — це набір інструкцій, які комп'ютер може зрозуміти й
          виконати.
        </p>
        <p>
          <dfn>Компілятор, інтерпретатор</dfn> - спеціальна програма, яка
          конвертує вихідний код у набір інструкцій, зрозумілих комп'ютеру.
        </p>
        <p>
          <dfn>Вихідний код (source code)</dfn> — це текст комп'ютерної
          програми, набір синтаксичних конструкцій, що описують набір інструкцій
          для комп'ютера.
        </p>
        <p><dfn>Алгоритм</dfn> — це набір кроків, задля досягнення мети.</p>
        <p><dfn>Алгоритм</dfn> створення програми</p>
        <ul>
          <li>розбити завдання на більш дрібні підзавдання;</li>
          <li>визначити послідовність виконання підзавдань;</li>
          <li>
            використовувати відповідні інструменти для розв’язання завдання.
          </li>
        </ul>

        <p>
          Необхідно добре знати синтаксис мови, тренуватися мислити алгоритмічно
        </p>

        <p>
          <dfn>Інструкція (statement)</dfn> — це пов'язаний набір слів і
          символів із синтаксису мови, які об'єднуються, щоб висловити одну
          ідею.
        </p>

        <code><pre>a = b * 2;</pre></code>
        <p>
          інструкції закінчуються <mark><code>;</code></mark>
        </p>
        <p>
          <mark><code>a</code></mark> і <mark><code>b</code></mark> — змінні —
          це сховища даних, які складаються з ідентифікатора (імені) та
          пов'язаного з ним значення.
        </p>

        <mark><code>2</code></mark> — просто число - називається значенням
        літералу (literal value).

        <p>
          <mark><code>= *</code></mark
          >— оператори, що виконують дії над значеннями та змінними.
        </p>

        <h3>Вираз та літерал. Expression and literal.</h3>

        <p>
          <dfn>Вираз (expression)</dfn> — це посилання на змінну чи значення,
          або на набір змінних і значень у поєднанні з операторами.
        </p>

        <p>
          <mark><code>b * 2</code></mark> — арифметичний вираз множення.
        </p>
        <p>
          <mark><code>a = b * 2</code></mark> — вираз присвоювання.
        </p>

        <p>
          Існують інші типи виразів: вирази виклику функцій, вирази порівняння
          тощо.
        </p>
        <code>
          <pre>
// Числовий літерал
10

// Рядковий літерал
"JavaScript is awesome!"
            </pre
          >
        </code>

        <h3>Підключення скрипта. Connect the script.</h3>
        <p>
          Для підключення скрипта JavaScript до HTML-сторінки можна використати
          тег <code>&lt;script&gt;</code>. Існує кілька способів, як це можна
          зробити:
        </p>

        <!-- Твій JavaScript-код тут -->
        <h5>Вбудований код з виводом інформаціє на веб сторінку</h5>

        <p id="definedd"></p>
        <script>
          const hi = "Hello, world";
          console.log(hi);
          document.getElementById("definedd").innerText = hi;
        </script>

        <p>
          <dfn>Суворий режим (англ. strict mode)</dfn> — режим повної
          відповідності сучасному стандарту, що запобігає певним помилкам,
          наприклад, використанню небезпечних і застарілих конструкцій.
        </p>
        <p>
          Щоб увімкнути суворий режим, потрібно додати директиву 'use strict';
          на початок скрипта.
        </p>

        <p>
          Комбінації клавіш відкривають інструменти розробника на вкладці
          Console: <mark>Ctrl + Shift + J;</mark>
        </p>

        <h4>Метод <code>console.log()</code></h4>
        <code>
          <pre>
              console.log("JavaScript is awesome!");
              console.log(10);
            </pre
          >
        </code>
        <script>
          console.log("JavaScript is awesome!");
          console.log(10);
        </script>

        <h3>Перевизначення значення. Overriding a value.</h3>
        <code>
          <pre>
              let username = "Mango";
              username = "Poly";
            </pre
          >
        </code>

        <p>
          Для оголошення змінної, якій згодом можна задати нове значення,
          використовується ключове слово <mark>let</mark>.
        </p>
        <p id="usernamePoly"></p>

        <p>
          Змінним, оголошеним через let, необов'язково відразу задавати
          значення. У разі оголошення змінної без значення, змінна
          ініціалізується зі спеціальним значенням
          <dfn>undefined (англ. не визначено)</dfn>.
        </p>

        <p id="userNameUndefined"></p>

        <p>
          Якщо звернутися до змінної до її оголошення з'явится помилка:
          "ReferenceError: age is not defined"
        </p>

        <p id="userAge"></p>

        <h3>Типи даних. Data types.</h3>

        <p>
          <dfn>Числа (Number)</dfn> - можуть бути позитивними, негативними,
          цілими або дробовими. Ціла та дробова частини числа розділяються
          крапкою.
        </p>

        <p>
          <dfn>Рядок (String)</dfn> - є послідовністю символів, вкладених в
          одинарні '' або подвійні лапки "".
        </p>

        <p>
          <dfn>Логічний тип даних (Boolean)</dfn> має лише два значення: true і
          false (пишеться без лапок на відміну від рядка).
        </p>

        <p>
          Імена змінних, що містять логічні значення, звучать як питання, на яке
          можна відповісти “так” чи “ні”.
        </p>

        <h3>Спеціальні значення. Special values.</h3>

        <p>
          <code><dfn>null</dfn></code> вказує на відсутність значення, часто
          використовується для позначення порожнього значення (має бути явно
          присвоєно змінній).
        </p>

        <code><dfn>undefined</dfn></code> автоматично присвоюється змінній,
        якщо:
        <ul>
          <li>змінній було явно задано значення undefined;</li>
          <li>
            змінна була оголошена, але ще не була ініціалізована значенням.
          </li>
        </ul>

        <p>
          Значення undefined каже нам, що значення на даний момент невідоме чи
          невизначене.
        </p>

        <h3>Оператор typeof. Operator typeof.</h3>

        <p>
          <code><dfn>typeof</dfn></code>
          використовується для визначення типу даних значення або виразу.
        </p>

        <p>
          <code><dfn>typeof</dfn></code> для перевірки типу значення null, він
          повертає рядок object.
        </p>

        <p>
          В ранніх версіях JavaScript null було розглянуто як спеціальний
          випадок об’єкта - це була помилка в реалізації мови, збережена для
          забезпечення зворотної сумісності з існуючим кодом.
        </p>

        <h3>Арифметичні операції</h3>

        <p>
          Правила порядку виконання операцій аналогічні математичним: спершу дії
          в дужках, потім степені й корені, потім множення та ділення тощо.
        </p>

        <ul>
          <li>
            Оператор (+) використовується для складання двох чисел.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x + y); // 13</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (-) використовується для віднімання одного числа від
            іншого.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x - y); // 3</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (*) використовується для множення двох чисел.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x * y); // 40</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (/) використовується для ділення одного числа на інше.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x / y); // 1.6</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (%) повертає остачу від ділення одного числа на інше.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x % y); // 3</pre
                >
              </code>
            </p>
          </li>
          <li>
            Оператор (**) використовується для піднесення числа до степеня.
            <p>
              <code>
                <pre>
const x = 8;
const y = 5;
console.log(x ** y); // 32768</pre
                >
              </code>
            </p>
          </li>
        </ul>

        <p>
          Доповни код, присвоївши змінній totalPrice вираз для підрахунку
          загальної суми замовлення. Змінна pricePerItem зберігає ціну за
          одиницю товару, а orderedQuantity - кількість одиниць товару в
          замовленні.
        </p>

        <p>
          <code>
            <pre>
const pricePerItem = 3500;
const orderedQuantity = 4;

// Change code below this line
const totalPrice = pricePerItem * orderedQuantity;</pre
            >
          </code>
        </p>

        <p>
          <dfn>Комбіновані оператори</dfn> дозволяють більш компактно виконувати
          арифметичні операції та одночасно оновлювати значення змінної,
          виходячи з її попереднього значення.
        </p>

        <ul>
          <li>
            <dfn>Додавання:</dfn> <code>+=</code>. Приклад:
            <code>x += y</code> еквівалентно <code>x = x + y</code>
          </li>
          <li>
            <dfn>Віднімання:</dfn> <code>-=</code>. Приклад:
            <code>x -= y</code> еквівалентно <code>x = x - y</code>
          </li>
          <li>
            <dfn>Множення:</dfn> <code>*=</code>. Приклад:
            <code>x *= y</code> еквівалентно <code>x = x * y</code>
          </li>
          <li>
            <dfn>Ділення:</dfn> <code>/=</code>. Приклад:
            <code>x /= y</code> еквівалентно <code>x = x / y</code>
          </li>
          <li>
            <dfn>Остача від ділення:</dfn> <code>%=</code>. Приклад:
            <code>x %= y</code> еквівалентно <code> x = x % y</code>
          </li>
        </ul>

        <p id="age"></p>

        <h3>
          Конкатенація (склеювання) рядків. Concatenation (gluing) of strings.
        </h3>
        <p>
          Якщо застосувати оператор + до рядка та будь-якого іншого типу даних,
          результатом буде новий рядок, що містить об'єднання вихідних значень.
          Це називається <dfn>конкатенація (склеювання)</dfn>. Під час
          конкатенації будь-який тип даних буде приведено до рядка та поєднано з
          іншим рядком.
        </p>

        <p>
          <code>
            <pre>
const message = "Mango " + "is" + " happy";
console.log(message); // "Mango is happy"</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
const age = 24;
const message = "Poly is " + age + " years old!";</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
console.log("Mango" + 55); // "Mango55"
console.log("Mango" + true); // "Mangotrue"</pre
            >
          </code>
        </p>

        <p>
          Проте порядок операндів має значення. Перетворення типів відбувається
          лише в момент операції додавання з рядком. До цього моменту
          застосовуються нормальні правила математики.
        </p>

        <p>
          <code>
            <pre>
console.log(1 + "2"); // "12"
console.log(1 + "2" + 4); // "124"
console.log(1 + 2 + "4"); // "34"</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
const username = "Poly";
const message = "Welcome " + username + "!";
console.log(message);</pre
            >
          </code>
        </p>

        <h3>Перетворення типів: рядки. Converting types: strings.</h3>
        <p>
          Перетворення типів у JavaScript — це процес зміни значення одного типу
          даних на інший тип даних. У JavaScript існують два типи перетворення:
          явне та неявне.
        </p>

        <h4>Явне перетворення типів</h4>
        <p>
          Для перетворення будь-якого значення на рядок можна використовувати
          вбудовану функцію <code>String()</code>
        </p>

        <p>
          <code>
            <pre>
console.log(String(5)); // "5"
console.log(String(true)); // "true"
console.log(String(false)); // "false"
console.log(String(null)); // "null"
console.log(String(undefined)); // "undefined"</pre
            >
          </code>
        </p>
        <p>
          Наприклад, якщо виконується операція додавання (<code>+</code>) між
          рядком та іншим типом даних, JavaScript автоматично перетворює
          значення операнда на рядок і виконує конкатенацію рядків.
        </p>

        <h4>Неявне перетворення типів</h4>

        <p>
          <code>
            <pre>
console.log("5" + 3); // "53"
console.log("5" + true); // "5true"
console.log("5" + false); // "5false"
console.log("5" + null); // "5null"
console.log("5" + undefined); // "5undefined"</pre
            >
          </code>
        </p>

        <p>
          <dfn>Шаблонні рядки</dfn> — це синтаксис, який полегшує об'єднання
          статичного тексту з динамічним (тобто текстом, що містить змінні,
          обчислення тощо).
        </p>

        <p>
          Код не працюватиме, якщо огорнути шаблонні рядки звичайними одинарними
          або подвійними лапками.
        </p>

        <p>
          Шаблонні рядки дозволяють підставляти значення змінних безпосередньо
          всередині рядка за допомогою синтаксису інтерполяції
          <code>${змінна}</code>.
        </p>

        <p>
          <code>
            <pre>
const guestName = "Mango";
const roomNumber = 207;
const greeting = `Welcome ${guestName}, your room number is ${roomNumber}!`;
console.log(greeting); // "Welcome Mango, your room number is 207!"</pre
            >
          </code>
        </p>

        <h4>Порівняння конкатенації та шаблонних рядків</h4>

        <p>Код з конкатенацією.</p>
        <p>
          <code>
            <pre>
const guestName = "Mango";
const roomNumber = 207;
const greeting =
  "Welcome " + guestName + ", your room number is " + roomNumber + "!";
console.log(greeting); // "Welcome Mango, your room number is 207!"</pre
            >
          </code>
        </p>

        <p>Код, де значення змінних підставляються у шаблонний рядок.</p>
        <p>
          <code>
            <pre>
const guestName = "Mango";
const roomNumber = 207;
const greeting = `Welcome ${guestName}, your room number is ${roomNumber}!`;
console.log(greeting); // "Welcome Mango, your room number is 207!"</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
const productName = "Droid";
const pricePerItem = 3500;

// Change code below this line
const message = `You picked ${productName}, price per item is ${pricePerItem} credits`;</pre
            >
          </code>
        </p>

        <h4>Замовлення продукту</h4>

        <p>
          <code>
            <pre>
const pricePerDroid = 800;
const orderedQuantity = 6;
const deliveryFee = 50;
const totalPrice = pricePerDroid * orderedQuantity + deliveryFee;
const message = `You ordered droids worth ${totalPrice} credits`;
console.log(message);</pre
            >
          </code>
        </p>

        <h3>Довжина рядка. Length of the string.</h3>
        <p><dfn>Властивості</dfn> — це описові характеристики сутності.</p>
        <p>
          Для доступу до властивості (<mark>property</mark>) сутності
          (<mark>objectName</mark>) використовується синтаксис із крапкою:
        </p>

        <p><code>сутність.властивість</code></p>

        <p>
          Наприклад, щоб отримати довжину рядка, ми можемо використовувати
          властивість <code>length</code> таким чином:
        </p>

        <p>
          <code>
            <pre>
const productName = "Repair droid";

// Якщо у змінній зберігається рядок
console.log(productName.length); // 12

// Якщо рядковий літерал
console.log("Repair droid".length); // 12</pre
            >
          </code>
        </p>

        <p>
          <code>
            <pre>
const username = "Poly";
const message = `Username ${username} is ${username.length} characters long`;
console.log(message);

Username Poly is 4 characters long
</pre
            >
          </code>
        </p>

        <h4>Індексація рядків. String indexing.</h4>
        <p>
          <dfn>Рядки</dfn> — це набори символів, де кожен символ має свій
          порядковий номер (індекс). Індексація елементів рядка починається з
          нуля.
        </p>

        <p>
          Для доступу до певного символу рядка ми використовуємо синтаксис
          квадратних дужок, де вказуємо індекс потрібного символу:
          <code>string[index]</code>.
        </p>

        <p>
          <code>
            <pre>
const product = "Repair droid";
console.log(product[0]); // 'R'
console.log(product[5]); // 'r'
console.log(product[11]); // 'd'
</pre
            >
          </code>
        </p>

        <p>
          Отримання останнього символу рядка можливе за його індексом
          <code>string[lastIndex]</code>. Щоб знайти індекс останнього символу
          рядка, треба від довжини цього рядка відняти одиницю
          <code>string.length - 1</code>
        </p>

        <p>
          <code>
            <pre>
const product = "Repair droid";
const lastElementIndex = product.length - 1;
console.log(product[lastElementIndex]); // 'd'
</pre
            >
          </code>
        </p>

        <p>
          Для доступу до останнього символу рядка без створення проміжної
          змінної ми можемо вставити вираз (<code>product.length - 1</code>) у
          квадратні дужки при зверненні до елемента.
        </p>

        <p>
          <code>
            <pre>
const product = "Repair droid";
console.log(product[product.length - 1]); // 'd'
</pre
            >
          </code>
        </p>

        <p>Додай код, який записує у змінні наступні значення:</p>

        <p><code>courseTopicLength</code> - довжина рядка</p>
        <p><code>firstElement</code> - перший символ рядка</p>
        <p>
          <code>lastElement</code> - останній символ рядка (використовуй змінну
          courseTopicLength)
        </p>

        <p>
          <code>
            <pre>
const courseTopic = "JavaScript essentials";

const courseTopicLength = courseTopic.length;
const firstElement = courseTopic[0];
const lastElement = courseTopic[courseTopicLength - 1]; 

</pre
            >
          </code>
        </p>

        <h3>Незмінність рядків. String immutability.</h3>

        <p>
          Коли рядок створюється, він стає незмінним (не можна замінити окремі
          символи всередині рядка).
        </p>

        <p>
          <code>
            <pre>
let product = "Droid";
console.log(product); // "Droid"

// Це не має жодного ефекту
product[2] = "O";
console.log(product); // "Droid" 
</pre
            >
          </code>
        </p>

        <p>
          Натомість ми повинні створити новий рядок і присвоїти його змінній
          новий рядок замість старого .
        </p>

        <p>
          <code>
            <pre>
let product = "Droid";
console.log(product); // "Droid"

product = "DrOid";
console.log(product); // "DrOid"
</pre
            >
          </code>
        </p>

        <!-- Section: Comparison operators.-->

        <h3>Оператори порівняння. Comparison operators.</h3>

        <p>
          Оператори порівняння повертають булеве значення (<code>true</code> або
          <code>false</code>) залежно від результату порівняння.
        </p>

        <p>Оператор &gt; (більше);</p>
        <p>Оператор &lt; (менше);</p>
        <p>Оператор &gt;= (більше або дорівнює);</p>
        <p>Оператор &lt;= (менше або дорівнює)</p>

        <p>
          <code>
            <pre>
const a = 2;
const b = 5;

console.log(a &gt; b); // false
console.log(b &gt; a); // true
console.log(a &gt;= b); // false
console.log(b &gt;= a); // true

console.log(a &lt; b); // true
console.log(b &lt; a); // false
console.log(a &lt;= b); // true
console.log(b &lt;= a); // false
</pre
            >
          </code>
        </p>

        <p>
          Оголоси змінну <code>isAdult</code> та задай їй результат перевірки
          значення змінної <code>age</code>. Використай оператори порівняння та
          доповни код так, щоб значенням <code>isAdult</code> було
          <code>true</code>, якщо вік користувача більше або дорівнює 18 та
          <code>false</code>, якщо менше 18.
        </p>

        <p>
          <code>
            <pre>
const age = 16; 
const isAdult = age >= 18;

console.log(isAdult);
</pre
            >
          </code>
        </p>

        <h3>Оператори рівності</h3>

        <p>Оператор == (дорівнює);</p>
        <p>Оператор != (не дорівнює);</p>

        <p>
          <code>
            <pre>
console.log(5 == 5); // true
console.log(5 == 3); // false
console.log(5 != 3); // true
console.log(5 != 5); // false
</pre
            >
          </code>
        </p>

        <p>Оператор === (сувора рівність);</p>
        <p>Оператор !== (сувора нерівність)</p>

        <p>
          <code>
            <pre>
console.log(5 === 5); // true
console.log(5 === "5"); // false
console.log(5 !== "5"); // true
console.log(5 !== 5); // false
console.log(1 === true); // false
console.log(1 !== true); // true
</pre
            >
          </code>
        </p>

        <p>
          Оголоси змінну <code>isValid</code> і задай їй значенням результат
          перевірки рівності паролей в змінних <code>correctPassword</code> і
          <code>userPassword</code>. Якщо паролі співпадають (сувора рівність),
          значення <code>isValid</code> має бути true Якщо паролі не
          співпадають, значення <code>isValid</code> має бути <code>false</code>
        </p>

        <p>
          <code>
            <pre>
const correctPassword = "jqueryismyjam";
const userPassword = "mangodab3st";
const isValid = correctPassword === userPassword;
</pre
            >
          </code>
        </p>

        <h4>Перетворення типів: числа</h4>
        <p>
          Для явного перетворення будь-якого значення в число можна
          використовувати вбудовану функцію <code>Number()</code>, яка повертає
          результат у вигляді числа.
        </p>

        <p>
          <code>
            <pre>
console.log(Number("5")); // 5
console.log(Number(true)); // 1
console.log(Number(false)); // 0
console.log(Number(null)); // 0
</pre
            >
          </code>
        </p>

        <p>true завжди приводиться до 1;</p>
        <p>false , null і "" завжди приводяться до 0.</p>

        <p>
          Якщо неможливо привести значення до числа, результатом перетворення
          буде спеціальне значення <code>NaN</code> (Not a Number).
        </p>

        <p>
          <code>
            <pre>
console.log(Number(undefined)); // NaN
console.log(Number("Jacob")); // NaN
console.log(Number("25px")); // NaN
</pre
            >
          </code>
        </p>

        <p>
          Арифметичні операції (<code>+, -, *, /</code>) виконують неявне
          перетворення типів.
        </p>

        <p>
          <code>
            <pre>
console.log("5" * 2); // 10
console.log("10" - 5); // 5
console.log(5 + true); // 6
console.log(5 - true); // 4
</pre
            >
          </code>
        </p>

        <p>
          Якщо у виразі присутній хоча б один із операндів з типом числа, то
          обидва операнди приводяться до чисел. Це відбувається у всіх
          арифметичних операціях, окрім додавання. + біля рядкових операндів
          викликає їх з'єднання (конкатинацію).
        </p>

        <p>
          У разі використання операторів порівняння (&lt;, &gt;, &lt;=, &gt;=)
          також виконується неявне перетворення типів. Якщо операнди різних
          типів, то перед порівнянням вони приводяться до числа.
        </p>

        <p>
          <code>
            <pre>
console.log("10" &gt; 5); // true
console.log(10 &gt; "5"); // true
console.log(5 &gt; true); // true
console.log(5 &lt; true); // false
console.log("5" &lt; true); // false
</pre
            >
          </code>
        </p>

        <h3>Перетворення рядків у числа.</h3>

        <p>Метод <code>Number.parseInt()</code> приймає 2 аргументи:</p>

        <ul>
          <li>
            Рядок. Якщо аргумент не є рядком, то він буде спочатку перетворений
            у рядок
          </li>
          <li>
            Система числення, до якої відноситься рядок (не обов’язковий
            аргумент, за замовчуванням десяткова система). Наприклад, для
            десяткової системи буде 10, для шістнадцяткової - 16 тощо.
          </li>
        </ul>

        <p>
          Метод аналізує рядок зліва направо, видаляючи пробіли на початку і
          перетворюючи допустимі символи у число до тих пір, поки не зіткнеться
          з першим недопустимим символом. Після цього аналіз припиняється, і вже
          перетворене ціле число повертається.
        </p>

        <p>
          <code>
            <pre>
console.log(Number.parseInt("5")); // 5
console.log(Number.parseInt("5.5")); // 5
console.log(Number.parseInt("5cm")); // 5
console.log(Number.parseInt("12qwe74")); // 12
console.log(Number.parseInt("12.46qwe79")); // 12
console.log(Number.parseInt("cm5")); // NaN
console.log(Number.parseInt("")); // NaN
console.log(Number.parseInt("qweqwe")); // NaN
</pre
            >
          </code>
        </p>

        <p>
          Якщо перші символи рядка не можуть бути перетворені на число, або
          рядок порожній чи відсутній, результатом буде значення NaN (Not a
          Number).
        </p>

        <h4>Метод <code>Number.parseFloat()</code></h4>

        <p>
          Метод <code>Number.parseFloat()</code> аналогічний
          <code>Number.parseInt()</code> з однієї відмінністю: перетворює рядок
          на число з плаваючою крапкою.
        </p>

        <p>
          <code>
            <pre>
console.log(Number.parseFloat("5")); // 5
console.log(Number.parseFloat("5.5")); // 5.5
console.log(Number.parseFloat("3.14")); // 3.14
console.log(Number.parseFloat("5cm")); // 5
console.log(Number.parseFloat("5.5cm")); // 5.5
console.log(Number.parseFloat("12qwe74")); // 12
console.log(Number.parseFloat("12.46qwe79")); // 12.46
console.log(Number.parseFloat("cm5")); // NaN
console.log(Number.parseFloat("")); // NaN
console.log(Number.parseFloat("qweqwe")); // NaN
</pre
            >
          </code>
        </p>

        Порожній чи відсутній, результатом буде значення
        <code>NaN (Not a Number)</code>.

        <!--  -->
        <h4>Арифметичні функції. Arithmetic functions.</h4>

        <p>
          Клас Math надає методи для виконання математичних операцій та роботи з
          числами.
        </p>
        <p>Клас Math є вбудованим класом JavaScript.</p>
        <p>Кілька методів, які надає клас Math:</p>

        <ul>
          <li>
            <mark>Math.floor(num):</mark> повертає найближче ціле число, яке є
            меншим або дорівнює вказаному числу <mark>num</mark>.

            <code>
              <pre>
    console.log(Math.floor(1.3)); // 1
    console.log(Math.floor(1.7)); // 1
            </pre
              >
            </code>
          </li>

          <li>
            <mark>Math.ceil(num):</mark> повертає найближче ціле число, яке є
            більшим, або дорівнює зазначеному числу <mark>num</mark>.
            <p>
              <code>
                <pre>
    console.log(Math.ceil(1.3)); // 2
    console.log(Math.ceil(1.7)); // 2
                  </pre
                >
              </code>
            </p>
          </li>

          <li>
            <mark>Math.round(num):</mark> повертає значення числа після
            округлення за математичними правилами - якщо десяткова частина числа
            менша 0.5, то округлення буде в меншу сторону, якщо 0.5 і більше —
            то в більшу.<mark>num</mark>.
            <p>
              <code>
                <pre>
    console.log(Math.round(1.3)); // 1
    console.log(Math.round(1.7)); // 2
                  </pre
                >
              </code>
            </p>
          </li>

          <li>
            <mark>Math.max(num1, num2, ...):</mark> повертає найбільше число з
            набору переданих чисел.
            <p>
              <code>
                <pre>
    console.log(Math.max(20, 10, 50, 40)); // 50
                </pre>
              </code>
            </p>
          </li>

          <li>
            <mark>Math.min(num1, num2, ...):</mark> повертає найменше число з
            набору переданих чисел.
            <p>
              <code>
                <pre>
    console.log(Math.min(20, 10, 50, 40)); // 10
                </pre>
              </code>
            </p>
          </li>

          <li>
            <mark>Math.random():</mark> повертає випадкове число в діапазоні від
            0 (включно) до 1 (за винятком).
            <p>
              <code>
                <pre>
    console.log(Math.random()); // випадкове число між 0 і 1, наприклад 0.2 ... 0.9166353649342294
                </pre>
              </code>
            </p>
          </li>

          <p>
            Math, також надає методи для тригонометричних функцій, логарифмів та
            інших математичних операцій.
          </p>
        </ul>

        <h4>Дробове число. Fractional number.</h4>
        <p>0.1 + 0.2 не дорівнює 0.3.</p>
        <p>
          Число 0.1 у двійковій системі числення, яку використовує комп'ютер —
          це нескінченний дріб.
        </p>
        <p>
          Двійкове значення нескінченних дробів зберігається лише до певного
          знака.
        </p>
        <p>
          <code>
            <pre>
    console.log(0.1 + 0.2 === 0.3); // false
    console.log(0.1 + 0.2); // 0.30000000000000004
                  </pre
            >
          </code>
        </p>
        <p>
          Щоб при додаванні двох дробових чисел, наприклад 0.1 + 0.2 виходило
          0.3, можна використати два підходи.
        </p>
        <ul>
          <li>
            1. Помножити числа на досить велике число (наприклад, 10 або 100),
            виконати додавання, зозділити результат на те саме число, щоб
            повернути його до початкового масштабу.
            <code>
              <pre>
    console.log(0.1 * 10 + 0.2 * 10); // 3
    console.log((0.1 * 10 + 0.2 * 10) / 10); // 0.3
                  </pre
              >
            </code>
          </li>
          <li>
            2. Метод <code><mark>toFixed()</mark></code> для округлення
            результату до певної кількості знаків після крапки.
            <code>
              <pre>
    console.log((0.1 + 0.2).toFixed(1)); // "0.3"
    console.log((5).toFixed(2));  //  ”5.00”
    console.log((8.762195).toFixed(4));  //  “8.7622”
                  </pre
              >
            </code>
          </li>
        </ul>

        <!--  -->
        <h3>Основи функцій. The basics of functions.</h3>
        <h4>Оголошення та виклик функції. Declaring and calling functions.</h4>
        <p>Cтруктура оголошення функції</p>
        <ol>
          <li>Ключове слово function</li>
          <li>
            Ім'я функції — дієслово, що відповідає на питання "Що зробити?"
          </li>
          <li>Пара круглих дужок ()</li>
          <li>Тіло функції у фігурних дужках {}</li>

          <code>
            <pre>
    function doStuff() {
  // Тіло функції
  console.log('Log inside multiply function');
}
                  </pre
            >
          </code>
        </ol>
        <p>
          Тіло функції містить інструкції, які потрібно виконати. Ці інструкції
          можуть включати оператори, умовні конструкції, цикли та інші функції.
        </p>
        <p>
          Коли функцію потрібно виконати, вона викликається за допомогою її
          імені та пари круглих дужок.
        </p>
        <code>
          <pre>
    // Оголошення функції multiply
function doStuff() {
  // Тіло функції
  console.log('Log inside multiply function');
}

// Виклики функції multiply
doStuff(); // 'Log inside multiply function'
doStuff(); // 'Log inside multiply function'
doStuff(); // 'Log inside multiply function'
                  </pre
          >
        </code>
        <h4>Параметри та аргументи. Parameters and arguments.</h4>
        <dfn>Параметри</dfn> — це локальні змінні, доступні лише всередині тіла
        функції.
        <p>
          Функція може мати будь-яку кількість параметрів або не мати їх
          взагалі, у такому випадку вказуються порожні круглі дужки.
        </p>

        <code>
          <pre>
        // Оголошення параметрів x, y, z
function multiply(x, y, z) {
  console.log(`Result: ${x * y * z}`);
}
        </pre
          >
        </code>

        <p>
          Під час виклику функції в круглих дужках можна передати аргументи, які
          є значеннями для оголошених параметрів функції.
        </p>

        <code>
          <pre>
    // Оголошення параметрів x, y, z
function multiply(x, y, z) {
  console.log(`Result: ${x * y * z}`);
}

// Передача аргументів
multiply(2, 3, 5); // "Result: 30"
multiply(4, 8, 12); // "Result: 384"
multiply(17, 6, 25); // "Result: 2550"
                  </pre
          >
        </code>
        <h4>Повернення значення. Return value.</h4>
        <p>
          Оператор return використовується для повернення значення з тіла
          функції назад у код, у місце її виклику. Коли інтерпретатор зустрічає
          оператор return, він виходить із функції (припиняє її виконання) і
          повертає вказане після return значення в місце виклику функції.
        </p>

        <code>
          <pre>
    function multiply(x, y, z) {
	const product = x * y * z;
  // Повертаємо результат виразу множення
  return product;
}

// Результат роботи функції можна зберегти у змінну
const result = multiply(2, 3, 5);
console.log(result); // 30
                  </pre
          >
        </code>
        <p>
          Щоб уникнути оголошення зайвої змінної в тілі функції, можна відразу ж
          повертати результат виразу без створення окремої змінної для
          зберігання результату виразу.
        </p>

        <code>
          <pre>
    function multiply(x, y, z) {
  return x * y * z;
}

const result = multiply(2, 3, 5);
console.log(result); // 30
                  </pre
          >
        </code>
        <p>
          Якщо в тілі функції відсутній оператор return або він не вказує на
          конкретне значення, функція поверне спеціальне значення undefined.
        </p>

        <code>
          <pre>
    function multiply(x, y, z) {
	const product = x * y * z;
}

const result = multiply(2, 3, 5);
console.log(result); // undefined
                  </pre
          >
        </code>

        <p>
          Всі інструкції які йдуть після оператора return в тілі функції не
          виконуються.
        </p>

        <code>
          <pre>
    function multiply(x, y, z) {
  console.log('The code before return is executed as usual');

  return x * y * z;

  console.log('This code is never executed because it is after return');
}

console.log(multiply(2, 3, 5)); // 30
                  </pre
          >
        </code>
        <h4>Порядок виконання коду. The order of code execution.</h4>
        <p>
          Коли інтерпретатор зустрічає виклик функції, він зупиняє виконання
          поточного коду й починає виконувати код з тіла функції.
        </p>
        <p>
          Після того, як весь код у функції буде виконано, інтерпретатор
          повертає управління в те місце, звідки був здійснений виклик функції,
          і продовжує виконання коду програми, що залишився.
        </p>
        <code>
          <pre>
     function multiply(x, y, z) {
   console.log(`Result: ${x * y * z}`);
  }

  console.log("Log before multiply execution");
  multiply(2, 3, 5); // "Result: 30"
  console.log("Log after multiply execution");
                  </pre
          >
        </code>

        <h4>Область видимості функції. The scope of the function.</h4>
        <p>
          Оголошєна змінна або функцію "видима" в певній частині коду, що
          обумовлюе можливість її використання.
        </p>

        <p>
          Змінні або функції, оголошені поза блоками коду (в глобальній області
          видимості), будуть доступні в будь-якій частині коду - це є глобальні
          змінними.
        </p>
        <p>
          Конструкція, що використовує фігурні дужки {} (умови, цикли, функції
          тощо) створює нову локальну область видимості. Змінні, оголошені в
          локальній області видимості, використовуються тільки всередині цього
          блоку коду.
        </p>
      </div>
    </section>
    <script src="js/jsgo.js"></script>
    <script src="js/connect.js" defer></script>
    <script src="js/typeof.js" defer></script>
  </body>
</html>
